\documentclass{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath, amsthm}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{listings}
\usepackage[svgnames]{xcolor}
\usepackage{tikz}
\usepackage{array}
\usepackage{graphicx}
\usepackage[backend=biber, maxbibnames=9]{biblatex}
\usepackage[noend]{algpseudocode}
\usepackage{algorithm}
\usepackage{mathtools}
\usepackage{xcolor}
\usepackage{subcaption}
\usepackage{wrapfig}
\usepackage{hhline}
\usepackage{bsymb}
\usepackage{longtable}
\usepackage{syntax}
\usepackage{ebproof}
\usepackage{hyperref}

% NOTE:
% File has moved to overleaf for collaboration!!!


% Commands
% Simple set comprehension notation
\newcommand{\Set}[2]{%
  \{\, #1 \mid #2 \, \}%
}
% Event-B-like set notation
\newcommand{\bSet}[3]{%
  \{\, #1 \cdot #2 \mid #3 \, \}%
}
\newcommand{\bSetT}[2]{%
  \{\, #1 \cdot #2 \,\}%
}

% Bag notation
% \newcommand{\lbbar}{\{\kern-0.5ex|}
% \newcommand{\rbbar}{|\kern-0.5ex\}}
\newcommand{\bag}[3]{%
  \llbracket \, #1 \cdot #2 \mid #3 \, \rrbracket%
}
\newcommand{\bagT}[2]{%
  \llbracket \, #1 \cdot #2 \,\rrbracket%
}

% List comprehension notation
\newcommand{\List}[3]{%
  [\, #1 \cdot #2 \mid #3 \, ]%
}
\newcommand{\ListT}[2]{%
  [\, #1 \cdot #2 \, ]%
}
% List concatenation
\newcommand{\concat}{%
  \mathbin{{+}\mspace{-8mu}{+}}%
}
% \DeclareUnicodeCharacter{29FA}{\concat}

% Lex table entry
\newcommand{\lexentry}[3]{%
  \ensuremath{#1} & \texttt{#2} & #3\\%
}

\newcommand{\ruleSpace}{\ \ \ }

% From https://tex.stackexchange.com/questions/82782/footnote-in-align-environment
\makeatletter
\let\original@footnote\footnote
\newcommand{\align@footnote}[1]{%
  \ifmeasuring@
    \chardef\@tempfn=\value{footnote}%
    \footnotemark
    \setcounter{footnote}{\@tempfn}%
  \else
    \iffirstchoice@
      \original@footnote{#1}%
    \fi
  \fi}
\pretocmd{\start@align}{\let\footnote\align@footnote}{}{}
\makeatother

% Modify appearance of nonterminals
% Enables italics for nonterminals
% \renewcommand{\syntleft}{\itshape}
\renewcommand{\syntleft}{}
\renewcommand{\syntright}{}

% Other preamble
\allowdisplaybreaks
\graphicspath{{./images/}}
% NOTE: need to run `biber <name>` to ensure up-to-date references
\addbibresource{citation.bib}

\title{Complete Specification and Design for Simile}
\author{Anthony Hunt}

\begin{document}
\maketitle
\tableofcontents
\newpage

\section{Overview}
This document serves as a living specification of the underlying term rewriting system used in the compiler for a modelling-focused programming language. It includes an overview of the language Simile, a user-facing reference, and implementation plans.


\subsection{High Level Ideas}

\paragraph{General Strategy}
A basic strategy to optimize set and relational expressions is:
\begin{enumerate}
  \item Normalize the expression as a set comprehensions
  \item Simplify and reorganize conjuncts of the set comprehension body
\end{enumerate}

\paragraph{Intuition}
The TRS for this language primarily involves lowering collection data type expressions into pointwise boolean quantifications. Breaking down each operation into set builder notation enables a few key actions:
\begin{itemize}
  \item Quantifications over sets ($\bSet{x}{G}{P}$) are naturally separated into generators ($G$) and (non-generating) predicates ($P$). For sets, at least one membership operator per top-level conjunction in $G$ will serve as a concrete element generator in generated code. Then, top level disjunctions will select one membership operation to act as a generator, relegating all others to the predicate level. For example, if the rewrite system observes an intersection of the form $\bSetT{x}{x \in S \land x \in T}$, the set construction operation must iterate over at least one of $S$ and $T$. Then, the other will act as a condition to check every iteration (becoming $\bSet{x}{x \in S}{x \in T}$).
  \item By definition of generators in quantification notation, operations in $G$ must be statements of the form $x \in S$, where $x$ is used in the ``element'' portion of the set construction. Statements like $x \notin T$ or checking a property $p(x)$ must act like conditions since they do not produce any iterable elements.
  \item Any boolean expression for conditions may be rewritten as a combination of $\lnot, \lor$, and $\land$ expressions. Therefore, by converting all set notation down into boolean notation and then generating code based on set constructor booleans, we can accommodate any form of predicate function.
\end{itemize}


% \paragraph{Granular Strategy (Sets)}
% % TODO take from report.tex, give supporting equations too (all the rules must be stable first)
% \begin{description}
%   \item[Set Comprehension Construction] Break down all qualifying sets into comprehension forms, collapsing and simplifying where needed.
%   \item[DNF Predicates] Revise comprehension predicates to top-level disjunctive normal form. Each or-clause should have at least one feasible generator. Each clause should record a list of candidate generators
%   \item[Predicate Simplification] Remove superfluous dummy variables, group or-clauses that use the exact same generator (ex. $\bSetT{x}{x \in S \land x \neq 0 \lor x \in S \land x = 0} \rightarrow \bSetT{x}{x \in S \land (x \neq 0 \lor x = 0)}$). Clauses should be group-able based on DNF, and generators should be selected and recorded.
%   \item[Set Code Generation] Converts quantifiers into for-loops and if-statements.
% \end{description}

% \section{Supported Operations}
% \begin{table}[H]
%     \centering
%     \caption{Summary table: a few operators on sets and relations.}
%     \begin{tabular}{|c|c||c|c|}
%     \hhline{|--||--|}
%     \multicolumn{2}{|c||}{Sets} & \multicolumn{2}{|c|}{Relations} \\
%     \hhline{:==::==:}
%     Syntax & Label/Description & Syntax & Label/Description\\
%     \hhline{|--||--|}
%     $set(T)$ & Unordered, unique collection             & $S \pfun T$ & Partial function \\
%     $S \leftrightarrow T$ & Relation, $set(S\times T)$  & $S \tinj T$& Total injection\\
%     $\emptyset$ & Empty set                             & $a \mapsto b$ & Pair (relational element) \\
%     $\{a,b,...\}$ & Set enumeration                     & $dom(S)$ & Domain\\
%     $\bSet{x}{x \in S}{P}$ & Set comprehension          & $ran(S)$ & Range\\
%     $S \cup T$ & Union                                  & $R[S]$ & Relational image\\
%     $S \cap T$ & Intersection                           & $R \ovl Q$ & Relational overriding\\
%     $S \setminus T$ & Difference                        & $R \circ Q$ & Relational composition\\
%     $S \times T$ & Cartesian Product                    & $S \triangleleft R$ & Domain restriction\\
%     $S \subseteq T$ & Subset                            & $R^{-1}$ & Relational inverse\\
%     \hhline{|--||--|}
%     % $f(S)$ & Function application\\ % is this like function mapping over a set? do we need to include this?
%     \end{tabular}
%     \label{tab:ADTOps}
% \end{table}
% \begin{table}[H]
%     \centering
%     \caption{Collection of operators on set data types.}
%     \begin{tabular}{|c|c|}
%         \hline
%         Name & Definition \\ %& Type &
%         \hline
%         Empty Set & Creates a set with no elements.\\ %& $\emptyset: set[]$ &
%         Set Enumeration & Literal collection of elements to create a set.\\ %& $\{x, y, ...\}: set[T]$ &
%         Set Membership & The term $x \in S$ is True if $x$ can be found somewhere in $S$. \\ %& $\in: T \times set[T] \rightarrow bool$ &
%         \hline
%         Union & $S \cup T = \bSetT{x}{x \in S \lor x \in T}$ \\ %& $\cup: set[T] \times set[T] \rightarrow set[T]$ &
%         Intersection & $S \cap T = \bSetT{x}{x \in S \land x \in T}$ \\ %& $\cap: set[T] \times set[T] \rightarrow set[T]$ &
%         Difference & $S \setminus T = \bSet{x}{x \in S}{x \notin T}$ \\ %& $\setminus: set[T] \times set[T] \rightarrow set[T]$ &
%         Cartesian Product & $S \times T = \bSetT{x \mapsto y}{x \in S \land y \in T}$ \\ %& $\times: set[T] \times set[V] \rightarrow relation[T,V]$ &
%         \hline
%         Powerset & $\mathbb{P}(S) = \bSetT{s}{s \subseteq S }$ \\ %& $\mathbb{P}: set[T] \rightarrow set[set[T]]$&
%         Magnitude & $\#S = \sum_{x \in S} 1$\\ %& $\#:set[T] \rightarrow int$ &
%         Subset & $S \subseteq T \equiv \forall x \in S: s \in T$ \\ %& $\subseteq: set[T] \times set[T] \rightarrow bool$ &
%         Strict Subset & $S \subset T \equiv S \subseteq T \land S \neq T$ \\ %& $\subset: set[T] \times set[T] \rightarrow bool$ &
%         Superset & $S \supseteq T \equiv \forall x \in T: s \in S$ \\ %& $\supseteq: set[T] \times set[T] \rightarrow bool$ &
%         Strict Superset & $S \supset T \equiv S \supseteq T \land S \neq T$ \\ %& $\supset: set[T] \times set[T] \rightarrow bool$ &
%         \hline
%         Set Mapping & $f * S = \bSetT{f(x)}{x \in S}$\\ %& $*: (T \rightarrow T') \times set[T] \rightarrow set[T']$ &
%         Set Filter & $p \triangleleft S = \bSet{x}{x \in S}{p(x)}$\\ %& $\triangleleft: (T \rightarrow bool) \times set[T] \rightarrow set[T]$ &
%         % Reduction & $f / S = $ %& $/:(T\times T \rightarrow T) \times set[T] \rightarrow T$ &
%         Set Quantification (Folding) & $\oplus x \cdot x \in S \mid P$\\
%         Cardinality & $card(S) = \sum 1 \cdot x \in S$\\
%         \hline
%     \end{tabular}
%     \label{tab:setOps}
% \end{table}
% \begin{table}[H]
%     \centering
%     \caption{Collection of operators on bag/multiset data types.}
%     \begin{tabular}{|c|c|}
%         \hline
%         Name & Definition \\ %& Type &
%         \hline
%         Empty Set & Creates a set with no elements.\\ %& $\emptyset: set[]$ &
%         Bag Enumeration & Literal collection of elements to create a set \\ & (for now, stored as a tuple of elements and number of occurrences).\\ %& $\{x, y, ...\}: set[T]$ &
%         Bag Membership & The term $x \in S$ is True if $S$ contains one or more occurrences of $x$. \\ %& $\in: T \times set[T] \rightarrow bool$ &
%         \hline
%         Union & $S \cup T = \bag{(x, a+b)}{(x,a) \in S \land (x,b) \in T}{a, b \geq 0}$ \\ %& $\cup: set[T] \times set[T] \rightarrow set[T]$ &
%         Intersection & $S \cap T = \bag{(x, min(a,b))}{(x,a) \in S \land (x,b) \in T}{a, b \geq 0}$ \\ %& $\cap: set[T] \times set[T] \rightarrow set[T]$ &
%         Difference & $S - T = \bag{(x, a-b)}{(x,a) \in S \land (x,b) \in T}{a, b \geq 0 \land a-b > 0}$ \\ %& $\setminus: set[T] \times set[T] \rightarrow set[T]$ &
%         % Cartesian Product & $S \times T = \bSetT{x \mapsto y}{x \in S \land y \in T}$ \\ %& $\times: set[T] \times set[V] \rightarrow relation[T,V]$ &
%         % \hline
%         % Powerset & $\mathbb{P}(S) = \bSetT{s}{s \subseteq S }$ \\ %& $\mathbb{P}: set[T] \rightarrow set[set[T]]$&
%         % Magnitude & $\#S = \sum_{x \in S} 1$\\ %& $\#:set[T] \rightarrow int$ &
%         % Subset & $S \subseteq T \equiv \forall x \in S: s \in T$ \\ %& $\subseteq: set[T] \times set[T] \rightarrow bool$ &
%         % Strict Subset & $S \subset T \equiv S \subseteq T \land S \neq T$ \\ %& $\subset: set[T] \times set[T] \rightarrow bool$ &
%         % Superset & $S \supseteq T \equiv \forall x \in T: s \in S$ \\ %& $\supseteq: set[T] \times set[T] \rightarrow bool$ &
%         % Strict Superset & $S \supset T \equiv S \supseteq T \land S \neq T$ \\ %& $\supset: set[T] \times set[T] \rightarrow bool$ &
%         % \hline
%         Bag Mapping & $f * S = \bagT{(f(x), r)}{(x, r) \in S}$\\ %& $*: (T \rightarrow T') \times set[T] \rightarrow set[T']$ &
%         Bag Filter & $p \triangleleft S = \bag{(x, r)}{(x, r) \in S}{p(x)}$\\ %& $\triangleleft: (T \rightarrow bool)
%         Size & $size(S) = \sum r \cdot (x, r) \in S$\\
%         Zero Occurrences & $(x,0) \in S \implies x \notin S$\\
%         \hline
%     \end{tabular}
%     \label{tab:setOps}
% \end{table}
% \begin{table}[H]
%     \centering
%     \caption{Collection of operators on sequence data types.}
%     \begin{tabular}{|c|c|}
%         \hline
%         Name & Definition \\ %& Type &
%         \hline
%         Empty List & Creates a list with no elements.\\ %& $[]: list[]$ &
%         List Enumeration & Literal collection of elements to create a list.\\ %& $[x, y, ...]: list[T]$ &
%         Construction & Alternative form of List Enumeration.\\ %& $(:):T \times list[T] \rightarrow list[T]$ &
%         List Membership & The term $x \texttt{ in } S$ is True if $x$ can be found somewhere in $S$. \\ %& $\texttt{in}: T \times list[T] \rightarrow bool$ &
%         \hline
%         Append & $[s_1, s_2, ..., s_n] + t = [s_1, s_2, ..., s_n, t]$ \\ %& $+: list[T] \times T \rightarrow list[T]$ &
%         Concatenate & $[s_1, ..., s_n] \concat [t_1, ..., t_n] = [s_1, ..., s_n, t_1, ... t_n]$ \\ %& $\concat: list[T] \times list[T] \rightarrow list[T]$ &
%         Length & $\#S = \sum 1 \cdot x \texttt{ in } S$ \\ %& $\#: list[T] \rightarrow int$ &
%         \hline
%         List Mapping & $f * S = \ListT{f(x)}{x \texttt{ in } S}$\\ %& $*: (T \rightarrow T') \times list[T] \rightarrow list[T']$ &
%         List Filter & $p \triangleleft S = \List{f(x)}{x \texttt{ in } S}{p(x)}$\\ %& $\triangleleft: (T \rightarrow bool) \times list[T] \rightarrow list[T]$ &
%         Associative Reduction & $\oplus / [s_1, s_2, ..., s_n] = s_1 \oplus s_2 \oplus ... \oplus s_n$\\ %& $/:(T\times T \rightarrow T) \times list[T] \rightarrow T$ &
%         Right Fold & $\texttt{foldr}(f, e, [s_1, s_2, ..., s_n]) = f(s_1 ,f(s_2 , f(..., f(s_n, e))))$\\ %& $\texttt{foldr}:(T\times V \rightarrow V) \times V \times list[T] \rightarrow V$ &
%         Left Fold & $\texttt{foldl}(f, e, [s_1, s_2, ..., s_n]) = f(f(f(f(e, s_1), s_2), ...), s_n)$\\ %& $\texttt{foldl}:(T\times T \rightarrow T) \times list[T] \rightarrow T$ &
%         \hline
%     \end{tabular}
%     \label{tab:seqOps}
% \end{table}
% \begin{table}[H]
%     \centering
%     \caption{Collection of operators on relation data types.}
%     \begin{tabular}{|c|c|}
%         \hline
%         Name & Definition \\ %& Type &
%         \hline
%         Empty Relation & Creates a relation with no elements.\\ %& $\{\}:relation[]$ &
%         Relation Enumeration & Literal collection of elements to create a relation.\\ %& $\{x \mapsto y, a \mapsto b,...\}: relation[T, V]$ &
%         Identity & $id(S)= \bSetT{x \mapsto x}{x \in S}$\\ %& $id: set[T] \rightarrow relation[T,T]$ &
%         Domain & $dom(R) = \bSetT{x}{x \mapsto y \in R}$\\ %& $dom: relation[T,V] \rightarrow set[T]$ &
%         Range & $ran(R) = \bSetT{y}{x \mapsto y \in R}$\\ %& $ran: relation[T,V] \rightarrow set[V]$ &
%         \hline
%         Relational Image & $R[S] = \bSet{y}{x \mapsto y \in R}{x \in S}$ \\ %& $([]): relation[T,V] \times set[T] \rightarrow set[V]$ &
%         Overriding & $R \ovl Q = Q \cup (dom(Q) \domsub R)$\\ %\Set{x \mapsto y}{x\mapsto y \in Q \lor (x \mapsto y \in R \land x \notin dom(Q))}$ \\ %& $\ovl: relation[T,V] \times relation[T,V] \rightarrow relation[T,V]$ &
%         (Forward) Composition & $Q \circ R = \bSetT{x \mapsto z}{x \mapsto y \in R \land y \mapsto z \in Q}$\\ %& $\circ: relation[V,W] \times relation[T,V] \rightarrow relation[T,W]$ &
%         Inverse & $R^{-1} = \bSetT{y \mapsto x}{x \mapsto y \in R}$ \\ %& $(^{-1}): relation[T,V] \rightarrow relation[V,T]$ &
%         \hline
%         Domain Restriction & $S \triangleleft R = \bSet{x \mapsto y}{x \mapsto y \in R}{x \in S}$\\ %& $\triangleleft: set[T] \times relation[T,V] \rightarrow relation[T,V]$ &
%         Domain Subtraction & $S \domsub R = \bSet{x \mapsto y}{x \mapsto y \in R}{x \notin S}$\\ %& $\domsub: set[T] \times relation[T,V] \rightarrow relation[T,V]$ &
%         Range Restriction & $R \triangleright S = \bSet{x \mapsto y}{x \mapsto y \in R}{y \in S}$\\ %& $\triangleright: set[V] \times relation[T,V] \rightarrow relation[T,V]$ &
%         Range Subtraction & $R \ransub S = \bSet{x \mapsto y}{x \mapsto y \in R}{y \notin S}$\\ %& $\ransub: set[V] \times relation[T,V] \rightarrow relation[T,V]$ &
%         % \hline % Do we need to include tests for total, surjective, injective, etc.?
%         % Eventually add closures
%         \hline
%     \end{tabular}
%     \label{tab:relOps}
% \end{table}

\section{Motivation} % Give examples, motivation, why we are taking this route, include steps for code generation, give intuition

\section{Language}
This section denotes the design and behaviour of Simile.

Much of the language design is inherited from Event-B and the mathematical language definition in \cite{metayerEventBMathLang}.

\subsection{Lexicon}
Since Simile makes extensive use of Event-B-like set notation and otherwise non-ASCII characters, this section contains a list of such characters, translations to ASCII symbols where suitable, and other useful lexing information.

\subsubsection{Whitespace}
Similar to Python, indentation and newline tokens are significant in Simile. In particular, nested code blocks, as in if-statements, for-loops, and procedure definitions, require the use of indentations to signify the beginning and end. Indentation/newlines may also be used within collection-type comprehensions or enumerations, similar to the style seen in JSON. Comments are single-lined and start with a pound symbol (\#).

\subsubsection{Identifiers}
Identifiers in Simile follow the standard regular expression, using only ASCII letters, underscores, and numbers: $[a-zA-Z\_][a-zA-Z\_0-9]$.

\subsubsection{Primitives}
Integers and floating point numbers follow a similar style to modern programming languages. The dash character ($-$) may be used in either subtraction or as a unary negation. Superscript numbers may be used for constant exponentiation. Booleans (True/False) follow Python style, with capitalized first letters. Strings are delimited with double-quotes (") and may be multilined.

% TODO: escaped characters in strings?

\subsubsection{Expressions}
ASCII tokens will be provided as an alternative to unicode format where suitable.

The following are symbols used for expressions:
\begin{center}
\begin{longtable}{c c l}
    \textbf{Token} & \textbf{ASCII Token} & \textbf{Name} \\
    \endhead
    \lexentry{\cdot}{.}{Center Dot (Quantifier Separator) \footnote{Anywhere $\cdot$ is valid, $.$ is valid.}}
    \lexentry{.}{}{Dot}
    \lexentry{,}{}{Comma}
    \lexentry{:}{}{Colon}
    \lexentry{;}{}{Semicolon}
    \lexentry{|}{}{Vertical Bar}
    \lexentry{\lambda}{lambda}{Lambda}
    \lexentry{(}{}{Left Parenthesis}
    \lexentry{)}{}{Right Parenthesis}
    \lexentry{\langle}{<{}<}{Left Bracket}
    \lexentry{}{[}{Left Bracket (Alternative)}
    \lexentry{\rangle}{>{}>}{Right Bracket}
    \lexentry{}{]}{Right Bracket (Alternative)}
    \lexentry{\{}{}{Left Brace}
    \lexentry{\}}{}{Right Brace}
    \lexentry{\llbracket}{[[}{Left Double Bracket}
    \lexentry{\rrbracket}{]]}{Right Double Bracket}
    \lexentry{=}{}{Equals}
    \lexentry{\neq}{!=}{Not Equals}
    \lexentry{\lnot}{not}{Not}
    \lexentry{}{!}{Not (Alternative)}
    \lexentry{\land}{and}{And}
    \lexentry{\lor}{or}{Or}
    \lexentry{\Rightarrow}{=>}{Implies}
    % \lexentry{\Leftarrow}{<==}{Reverse Implies}
    \lexentry{\equiv}{==}{Equivalent}
    % \lexentry{\equiv}{}{Equivalent (Alternative)}
    \lexentry{\not\equiv}{!==}{Not Equivalent}
    \lexentry{\forall}{forall}{For All}
    \lexentry{\exists}{exists}{There Exists}
    \lexentry{}{+}{Plus}
    \lexentry{}{-}{Minus}
    \lexentry{}{*}{Multiplication}
    \lexentry{}{/}{Division}
    \lexentry{}{div}{Integer Division}
    \lexentry{}{mod}{Modulo}
    \lexentry{}{\^}{Exponent}
    \lexentry{<}{}{Less Than}
    \lexentry{\leq}{<=}{Less Than or Equal}
    \lexentry{>}{}{Greater Than}
    \lexentry{\geq}{>=}{Greater Than or Equal}
    \lexentry{\in}{in}{In (Membership)}
    \lexentry{\not\in}{not in}{Not In (Membership)}
    \lexentry{\cup}{\textbackslash/}{Union}
    \lexentry{\cap}{/\textbackslash}{Intersection}
    \lexentry{\setminus}{\textbackslash}{Backslash (Set Minus)}
    \lexentry{\times}{><}{Cartesian Product}
    % \lexentry{\times}{><}{Cartesian Product}
    \lexentry{\subset}{<{}<:}{Subset}
    \lexentry{\subseteq}{<:}{Subset or Equal}
    \lexentry{\supset}{:>{}>}{Superset}
    \lexentry{\supseteq}{:>}{Superset or Equal}
    \lexentry{\not\subset}{!<{}<:}{Not Subset}
    \lexentry{\not\subseteq}{!<:}{Not Subset or Equal}
    \lexentry{\not\supset}{!:>{}>}{Not Superset}
    \lexentry{\not\supseteq}{!:>}{Not Superset or Equal}
    \lexentry{\bigcup}{union}{General Union}
    \lexentry{\bigcap}{intersection}{General Intersection}
    \lexentry{\mapsto}{|->}{Maplet}
    \lexentry{\oplus}{<+>}{Relation Overriding} % Old: \ovl \footnote{This unicode symbol requires a specific font available from Rodin: Brave Sans Mono, U+E103}}
    \lexentry{\circ}{circ}{Composition}
    \lexentry{\concat}{++}{Concatenation}
    \lexentry{^{-1}}{\~}{Inverse}
    \lexentry{\domres}{<|}{Domain Restriction}
    \lexentry{\domsub}{<{}<|}{Domain Subtraction}
    \lexentry{\ranres}{|>}{Range Restriction}
    \lexentry{\ransub}{|>{}>}{Range Subtraction}
    \lexentry{\rel}{<->}{Relation}
    \lexentry{\trel}{<{}<->}{Total Relation \footnote{Brave Sans Mono unicode: U+E100}}
    \lexentry{\srel}{<->{}>}{Surjective Relation \footnote{Brave Sans Mono unicode: U+E101}}
    \lexentry{\strel}{<{}<->{}>}{Total Surjective Relation \footnote{Brave Sans Mono unicode: U+E102}}
    \lexentry{\pfun}{+->}{Partial Function}
    \lexentry{\tfun}{-{}->}{Total Function}
    \lexentry{\pinj}{>+>}{Partial Injection}
    \lexentry{\tinj}{>->}{Total Injection}
    \lexentry{\psur}{+->{}>}{Partial Surjection}
    \lexentry{\tsur}{-{}->{}>}{Total Surjection}
    \lexentry{\tbij}{>->{}>}{Bijection}
    \lexentry{\upto}{}{Upto}
    \lexentry{\pow}{powerset}{Powerset}
    \lexentry{\pown}{powerset1}{Non-Empty Powerset}
\end{longtable}
\end{center}

The following are symbols used for programming constructs:
\begin{center}
\begin{longtable}{c c c c}
    \textbf{(Unicode) Token} & \textbf{(ASCII) Token} & \textbf{Name} \\
    \endhead
    \lexentry{\coloneqq}{:=}{Assignment}
    \lexentry{:\in}{::}{Choice (Non-deterministic Membership) Assignment}
    \lexentry{\rightarrow}{->}{Right Arrow}
\end{longtable}
\end{center}

\subsubsection{Reserved Keywords}
The following list of symbols and identifiers are reserved for programming constructs:

\begin{center}
\begin{tabular}{c c c c c c}
true & false & if & else & for\\
while & record & enum & procedure & is\\
is not & return & break & continue \\
from & import & skip & with & type  \\
min & max & choice &  &  &
\end{tabular}
\end{center}

\subsection{Syntax}
We follow the standard EBNF notation for describing the language structure.

\begin{grammar}
<Start> ::= <Statements>

<Statements> ::= \{<SimpleStmt> | <CompoundStmt>\}

% <Comment> ::= `\#' [\^{}NEWLINE]* NEWLINE

<SimpleStmt> ::= <Expr> [[`:' <Expr>] (\lit{$\coloneqq$} | \lit{$:\in$}) <Expr>] NEWLINE [<WithStmt>]
    \alt <ControlFlowStmt> NEWLINE
    \alt <ImportStmt> NEWLINE

<WithStmt> ::= INDENT `with' <Expr> NEWLINE \{<Expr> NEWLINE\} DEDENT

<ControlFlowStmt> ::= `return' [<Expr>]
    \alt `break'
    \alt `continue'
    \alt `skip'

<ImportStmt> ::= `import' STRING
    \alt `from' STRING `import' <ImportList>

<ImportList> ::= `*'
    \alt <FlatTupleIdentifier>

<FlatTupleIdentifier> ::= IDENTIFIER \{`,' IDENTIFIER \}
    \alt `(' IDENTIFIER \{`,' IDENTIFIER \} `)'

<Expr> ::= <Quantification> | <Predicate>

<Quantification> ::= \lit{$\lambda$} [<FlatTupleIdentifier>] \lit{$\cdot$} <Predicate> `|' <Expr>
    \alt \lit{$\bigcup$} <QuantificationBody>
    \alt \lit{$\bigcap$} <QuantificationBody>
    % \alt \lit{min} <QuantificationBody> % TODO remove and let min/max take in an iterable? May be better to just let min be a func like min({x,y,z . x > 1 | x}), could even add a key as a second optional argument
    % \alt \lit{max} <QuantificationBody>

<QuantificationBody> ::= <IdentList> \lit{$\cdot$} <Predicate> `|' <Expr>
    \alt <Expr> `|' <Predicate>

% TODO simplify this a lot - there shouldnt be any need for nested identlists right? should be the same style as a function call
% Really, those should be considered tuples - tuples can be used wherever exprs are used (eg. in arg of a function call), but theres really no need for nested tuple definitions/destructuring of that nature. Only top-level commas may be needed to separate bound identifiers/arguments, maplets for relational bound identifiers.
%
% Candidate Simplification:
% <IdentList> ::= <MapletIdentifier> \{ `,' <MapletIdentifier> \}
% <MapletIdentifier> ::= IDENTIFIER | <MapletIdentifier> \lit{$\mapsto$} IDENTIFIER
% Rename IdentList to BindIdentList to make it clearer that its only for binding identifiers (eg. in foreach loops, lambdas, or quantifiers
<IdentList> ::= <IdentListItem> \{`,' <IdentListItem>\}

<IdentListItem> ::= IDENTIFIER
    \alt <IdentListItem> \lit{$\mapsto$} <IdentListItem>
    \alt `(' <IdentList> `)'

% <IdentList> ::= <IdentPattern> \{`,' <IdentPattern>\}

% <IdentPattern> ::= <IdentSubPattern>
%     \alt <IdentSubPattern> \lit{$\mapsto$} <IdentPattern>

% <IdentSubPattern> ::= IDENTIFIER
%     \alt `(' <IdentList> `)'

<Predicate> ::= <UnquantifiedPredicate>
    \alt \lit{$\forall$} <IdentList> \lit{$\cdot$} <Predicate>
    \alt \lit{$\exists$} <IdentList> \lit{$\cdot$} <Predicate>

<UnquantifiedPredicate> ::= <Implication>
    \alt <UnquantifiedPredicate> (\lit{$\equiv$} | \lit{$\not\equiv$}) <Implication>

% TODO is this right? rev implies seems awkward
<Implication> ::= <Disjunction>
    \alt <Disjunction> \{\lit{$\Rightarrow$} <Disjunction>\}
    % \alt <Disjunction> \{\lit{$\impliedby$} <Implication>\}

<Disjunction> ::= <Conjunction> \{\lit{$\lor$} <Conjunction>\}

<Conjunction> ::= <Negation> \{\lit{$\land$} <Negation>\}

<Negation> ::= <AtomBool>
    \alt \lit{$\lnot$} <Negation>

<AtomBool> ::= <PairExpr> [(
        \lit{$=$}
      | \lit{$\neq$}
      % | \lit{is}
      % | \lit{is not}
      | `<'
      | `>'
      | \lit{$\leq$}
      | \lit{$\geq$}
      | \lit{$\in$}
      | \lit{$\not\in$}
      | \lit{$\subset$}
      | \lit{$\subseteq$}
      | \lit{$\supset$}
      | \lit{$\supseteq$}
      | \lit{$\not\subset$}
      | \lit{$\not\subseteq$}
      | \lit{$\not\supset$}
      | \lit{$\not\supseteq$}
    ) <PairExpr>]

<PairExpr> ::= <RelSetExpr>
    \alt <PairExpr> \lit{$\mapsto$} <RelSetExpr>

<RelSetExpr> ::= <SetExpr> [(
      \lit{$\rel$}
    | \lit{$\trel$}
    | \lit{$\srel$}
    | \lit{$\strel$}
    | \lit{$\pfun$}
    | \lit{$\tfun$}
    | \lit{$\pinj$}
    | \lit{$\tinj$}
    | \lit{$\psur$}
    | \lit{$\tsur$}
    | \lit{$\tbij$}
) <RelSetExpr>]

<SetExpr> ::= <IntervalExpr>
    \alt <IntervalExpr> \{\lit{$\cup$} <IntervalExpr>\}
    \alt <IntervalExpr> \{\lit{$\times$} <IntervalExpr>\}
    \alt <IntervalExpr> \{\lit{$\oplus$} <IntervalExpr>\}
    \alt <IntervalExpr> \{\lit{$\circ$} <IntervalExpr>\}
    \alt <IntervalExpr> \{\lit{$\cap$} <IntervalExpr>\}
    \alt <IntervalExpr> \{\lit{$\concat$} <IntervalExpr>\}
    \alt <IntervalExpr> (\lit{$\domsub$} | \lit{$\domres$}) <IntervalExpr> \{\lit{$\cap$} <IntervalExpr>\} [<RelSubExpr>]

<RelSubExpr> ::= (\lit{$\setminus$} | \lit{$\ranres$} | \lit{$\ransub$}) <IntervalExpr>

<IntervalExpr> ::= <ArithmeticExpr> [`..' <ArithmeticExpr>]

<ArithmeticExpr> ::= <Term>
    \alt <ArithmeticExpr> (`+' | `-') <Term>

% Need to have \times and * be different symbols - otherwise 1..n \times n is ambiguous - either the set of 1 to n*n or the set of 1..n, n times (I know the semantics for the second one dont make much sense, but it may be best to separate the two symbols because of the differing precedence around .. and +/-
<Term> ::= <Factor>
    \alt <Term> (`*' | `/' | `div' | `mod') <Factor>

<Factor> ::= [(`+' | `-')] <Power>

% Note, because of next production, if you see {}^{-1}, look for relational image operation
<Power> ::= <Primary> [\lit{\^{}} <Factor> | [\lit{${}^-$}](\lit{${}^{INTEGER}$} | \lit{${}^{FLOAT}$})]

<Primary> ::= <Atom>
    \alt <Atom> `.' IDENTIFIER
    \alt <Atom> `(' <Expr> \{`,' <Expr>\} `)'
    \alt <Atom> `[' <Expr> `]'

<Atom> ::= INTEGER | FLOAT | STRING | BOOLEAN | IDENTIFIER
    \alt <Set> | <Sequence> | <Bag> | <Tuple>
    \alt \lit{$\mathbb{P}$} `(' <Expr> `)' | \lit{$\mathbb{P}_1$} `(' <Expr> `)' | `(' <Expr> `)' % SEE NOTE for Tuple

<Set> ::= `{' <CollectionBody> `}'

<Bag> ::= \lit{$\llbracket$} <CollectionBody> \lit{$\rrbracket$}

<Sequence> ::= \lit{$\langle$} <CollectionBody> \lit{$\rangle$}

% Tuples either are empty, have one element (distinct from a parenthesized expr by a comma), or follow enumerationbody
% TODO check if this attempts to match to parenth expr in atom... may need to move tuple up to that function in the code
<Tuple> ::= `(' `)' | `(' [NEWLINE INDENT] <Expr> `,' [NEWLINE [INDENT]] [<EnumerationBody>] `)'

<CollectionBody> ::= <QuantificationBody> | <EnumerationBody>

<EnumerationBody> ::= [NEWLINE INDENT] <Expr> \{`,' [NEWLINE [INDENT]] <Expr>\} [NEWLINE DEDENT]

<CompoundStmt> ::= <IfStmt> | <ForStmt> | <WhileStmt>
    \alt <RecordStmt> | <ProcedureStmt>

<IfStmt> ::= `if' <Predicate> `:' <Block> [<ElseStmt>]

<ElseStmt> ::= `else :' <Block>
    \alt `else if' <Predicate> `:' <Block> [<ElseStmt>]

<ForStmt> ::= `for' <IdentList> \lit{$\in$} <Expr> `:' <Block>

<WhileStmt> ::= `while' <Expr> `:' <Block>

<RecordStmt> ::= `record' IDENTIFIER `:' NEWLINE INDENT ( \\
        `skip' | <TypedName> \{(`,' [NEWLINE] | NEWLINE) <TypedName> \} \\
    ) NEWLINE DEDENT

<ProcedureStmt> ::= `procedure' IDENTIFIER `(' <TypedName> \{`,' <TypedName> \} `)' \lit{$\rightarrow$} <Expr> `:' <Block>

% TODO should we force types to be provided?
<TypedName> ::= IDENTIFIER [`:' <Expr>]

<Block> ::= <SimpleStmt>
    \alt NEWLINE INDENT <Statements> DEDENT

\end{grammar}


\subsection{Static Analysis - Type System}
Let $\Gamma$ be the type environment set consisting of elements either $identifier: Type$ or $Type$. The typing rules have been organized in distinct categories for readability. The notation $Type[x, y, z]$ denotes refinements on $Type$ either through instantiating parametric (generic) types or restricting values by way of \texttt{with} clauses.

Type refinements may be applicable to types with certain traits (ex., min/max values for ordered types, definedness of expressions with certain values, set sizes). % Is there a way to formalize this? Refinement calculus?

\subsubsection{Base Environment Interactions}
\paragraph{Includes:} Mechanisms for adding/extracting variables from the type environment.

\begin{gather}
\tag{Env $\emptyset$}
\begin{prooftree}
\infer0{\emptyset \vdash \diamond}
\end{prooftree}
\\
\tag{Env $I$}
\begin{prooftree}
\hypo{\Gamma \vdash A}
\hypo{I \not\in dom(\Gamma)}
\infer2{\Gamma, I:A \vdash \diamond}
\end{prooftree}
\\
\tag{Fetch Identifier}
\begin{prooftree}
\hypo{\Gamma_1, I:A, \Gamma_2 \vdash \diamond}
\infer1{\Gamma_1, I:A, \Gamma_2 \vdash I:A}
\end{prooftree}
\end{gather}

\subsubsection{Subtype Interactions}
\paragraph{Includes:} Generic subtyping rules.

\begin{gather}
\tag{Reflexive Subtype}
\begin{prooftree}
\hypo{\Gamma \vdash A}
\infer1{\Gamma \vdash A \leq A}
\end{prooftree}
\\
\tag{Transitive Subtype}
\begin{prooftree}
\hypo{\Gamma \vdash A \leq B}
\hypo{\Gamma \vdash B \leq C}
\infer2{\Gamma \vdash A \leq C}
\end{prooftree}
\\
\tag{Subsumption}
\begin{prooftree}
\hypo{\Gamma \vdash a:A}
\hypo{\Gamma \vdash A \leq B}
\infer2{\Gamma \vdash a: B}
\end{prooftree}
\\
\tag{Top Type}
\begin{prooftree}
\hypo{\Gamma \vdash \diamond}
\infer1{\Gamma \vdash Any}
\end{prooftree}
\\
\tag{Sub Top Type}
\begin{prooftree}
\hypo{\Gamma \vdash A}
\infer1{\Gamma \vdash A \leq Any}
\end{prooftree}
\\
\tag{Sub Function}
\begin{prooftree}
\hypo{\Gamma \vdash A' \leq A}
\hypo{\Gamma \vdash B \leq B'}
\infer2{\Gamma \vdash A \rightarrow B \leq A' \rightarrow B'}
\end{prooftree}
\\
\tag{Sub Set}
% TODO check this - doesnt match up with the definition of set as set: A -> bool, but does work intuitively
% ex. set[nat] <= set[int]
\begin{prooftree}
\hypo{\Gamma \vdash A \leq B}
\infer1{\Gamma \vdash set[A] \leq set[B]}
\end{prooftree}
\\
\tag{Sub Product}
\begin{prooftree}
\hypo{\Gamma \vdash A_1 \leq B_1}
\hypo{\Gamma \vdash A_2 \leq B_2}
\infer2{\Gamma \vdash A_1 \times A_2 \leq B_1 \times B_2 }
\end{prooftree}
\\
\tag{Sub Record}
\begin{prooftree}
\hypo{\Gamma \vdash A_1 \leq B_1 ... A_n \leq B_n}
\hypo{\Gamma \vdash A_{n+1} ... A_{n+m}}
\infer2{\Gamma \vdash  Record[I_1: A_1, ..., I_n: A_n, I_{n+1}: A_{n+1}, ... I_{n+m}: A_{n+m}] \leq  Record[I_1: B_1, ..., I_n: B_n]}
\end{prooftree}
\\
\tag{Type Refinement}
\begin{prooftree}
\hypo{\Gamma \vdash T}
\infer1{\Gamma \vdash T[\text{with } x] \leq T}
\end{prooftree}
\end{gather}

\subsubsection{The Set Type}
\paragraph{Includes:} Universal type; everything is a set. The empty set is a part of every type (aside from primitives).

\begin{gather}
\tag{Powerset}
\begin{prooftree}
\hypo{\Gamma \vdash T}
\infer1{\Gamma \vdash set[T]}
\end{prooftree}
\\
\tag{Emptyset}
\begin{prooftree}
\hypo{\Gamma \vdash \diamond}
\infer1{\Gamma \vdash EmptySet}
\end{prooftree}
\\
\tag{Emptyset Bottom}
\begin{prooftree}
\hypo{\Gamma \vdash EmptySet, set[T]}
\infer1{EmptySet \leq set[T]}
\end{prooftree}
\\
\tag{Set Enumeration}
\begin{prooftree}
\hypo{\Gamma \vdash e_1, ..., e_n: A}
\infer1{\Gamma \vdash \{e_1, ..., e_n\}: set[A]}
\end{prooftree}
\end{gather}

\subsubsection{Primitive Types}
\paragraph{Includes:} Basic types built in to the language, like numbers (int and float), strings, and booleans. Although these could all be represented as sets, it is useful to distinguish these common types from other collections or user-defined types.

\begin{gather}
\tag{Primitives - bool}
\begin{prooftree}
\hypo{\Gamma \vdash \diamond}
\infer1{\Gamma \vdash bool }
\end{prooftree}
\\
\tag{Primitives - int}
\begin{prooftree}
\hypo{\Gamma \vdash \diamond}
\infer1{\Gamma \vdash int }
\end{prooftree}
\\
\tag{Primitives - float}
\begin{prooftree}
\hypo{\Gamma \vdash \diamond}
\infer1{\Gamma \vdash float }
\end{prooftree}
\\
\tag{Primitives - str}
\begin{prooftree}
\hypo{\Gamma \vdash \diamond}
\infer1{\Gamma \vdash str }
\end{prooftree}
\\
\tag{Nat from int}
\begin{prooftree}
\hypo{\Gamma \vdash int}
\infer1{\Gamma \vdash nat \leq int[\text{with } min=0] }
\end{prooftree}
\\
\tag{Int from float}
\begin{prooftree}
\hypo{\Gamma \vdash int, float}
\infer1{int \leq float }
\end{prooftree}
\end{gather}

\subsubsection{Collection Types}
\paragraph{Includes:} Sequences, relations, enums (frozen sets), and bags (multisets); Syntactic sugar for abstract data types defined in terms of sets.

\begin{gather}
\tag{Tuples}
\begin{prooftree}
\hypo{\Gamma \vdash T_1, ..., T_n}
\infer1{\Gamma \vdash tuple[T_1, ..., T_n] \ruleSpace tuple[T_1, ..., T_n] = T_1 \times ... \times T_n}
\end{prooftree}
\\
\tag{Empty Tuple}
\begin{prooftree}
\hypo{\Gamma \vdash \diamond}
\infer1{\Gamma \vdash (): EmptyTuple}
\end{prooftree}
\\
\tag{Empty Tuple Bottom}
\begin{prooftree}
\hypo{\Gamma \vdash EmptyTuple, T}
\infer1{\Gamma \vdash EmptyTuple \leq tuple[T]}
\end{prooftree}
\\
\tag{Tuple Enumeration}
\begin{prooftree}
\hypo{\Gamma \vdash e_1:A_1, ..., e_n: A_n}
\infer1{\Gamma \vdash ( e_1, ..., e_n ) : tuple[A_1, ..., A_n]}
\end{prooftree}
\\
\tag{Relation Type}
\begin{prooftree}
\hypo{\Gamma \vdash set[T_1], set[T_2]}
\infer1{\Gamma \vdash T_1 \rel T_2 \ruleSpace T_1 \rel T_2 = set[tuple[T_1, T_2]]}
\end{prooftree}
\\
\tag{Bag Type}
\begin{prooftree}
\hypo{\Gamma \vdash T, nat}
\infer1{\Gamma \vdash bag[T] \leq T \pfun nat }
\end{prooftree}
\\
\tag{Bag Enumeration}
\begin{prooftree}
\hypo{\Gamma \vdash e_1, ..., e_n: A}
\infer1{\Gamma \vdash \llbracket e_1, ..., e_n \rrbracket: bag[A]}
\end{prooftree}
\\
\tag{Sequence Type}
\begin{prooftree}
\hypo{\Gamma \vdash T, nat}
\infer1{\Gamma \vdash sequence[T] \leq nat \pfun T }
\end{prooftree}
\\
\tag{Sequence Enumeration}
\begin{prooftree}
\hypo{\Gamma \vdash e_1, ..., e_n: A}
\infer1{\Gamma \vdash \langle e_1, ..., e_n \rangle : sequence[A]}
\end{prooftree}
\\
\tag{Enum from static set}
\begin{prooftree}
\hypo{\Gamma \vdash s_1, ..., s_n : str}
\hypo{A = \{s_1, ..., s_n\} }
\hypo{immutable(A)}
\infer3{\Gamma \vdash enum[A] \leq set[A, \text{with } immutable]}
\end{prooftree}
\end{gather}



\subsubsection{Relation Subtypes}
\paragraph{Includes:} Relation subtypes examine four key properties of relations: totality ($t$), surjectivity ($t_r$), one-to-manyness ($1-$), and many-to-oneness ($1-_r$). Syntactic sugar to produce refined relations with these properties follows the definitions presented in Event-B. See Section 5.1.3 for more details.

\begin{gather}
\tag{Relation Subtype - Total Relation}
\begin{prooftree}
\hypo{\Gamma \vdash set[T_1], set[T_2]}
\infer1{\Gamma \vdash T_1 \trel T_2 \ruleSpace T_1 \trel T_2 = (T_1 \rel T_2)[\text{with } t]}
\end{prooftree}
\\
\tag{Relation Subtype - Surjective Relation}
\begin{prooftree}
\hypo{\Gamma \vdash set[T_1], set[T_2]}
\infer1{\Gamma \vdash T_1 \srel T_2 \ruleSpace T_1 \srel T_2 = (T_1 \rel T_2)[\text{with } t_r]}
\end{prooftree}
\\
\tag{Relation Subtype - Total Surjective Relation}
\begin{prooftree}
\hypo{\Gamma \vdash set[T_1], set[T_2]}
\infer1{\Gamma \vdash T_1 \strel T_2 \ruleSpace T_1 \strel T_2 = (T_1 \rel T_2)[\text{with } t, \text{ with } t_r]}
\end{prooftree}
\\
\tag{Relation Subtype - Partial Function}
\begin{prooftree}
\hypo{\Gamma \vdash set[T_1], set[T_2]}
\infer1{\Gamma \vdash T_1 \pfun T_2 \ruleSpace T_1 \pfun T_2 = (T_1 \rel T_2)[\text{with } 1-]}
\end{prooftree}
\\
\tag{Relation Subtype - Total Function}
\begin{prooftree}
\hypo{\Gamma \vdash set[T_1], set[T_2]}
\infer1{\Gamma \vdash T_1 \tfun T_2 \ruleSpace T_1 \tfun T_2 = (T_1 \rel T_2)[\text{with } t, \text{ with } 1-]}
\end{prooftree}
\\
\tag{Relation Subtype - Partial Injection}
\begin{prooftree}
\hypo{\Gamma \vdash set[T_1], set[T_2]}
\infer1{\Gamma \vdash T_1 \pinj T_2 \ruleSpace T_1 \pinj T_2 = (T_1 \rel T_2)[\text{with } 1-, \text{ with } 1-_r]}
\end{prooftree}
\\
\tag{Relation Subtype - Total Injection}
\begin{prooftree}
\hypo{\Gamma \vdash set[T_1], set[T_2]}
\infer1{\Gamma \vdash T_1 \tinj T_2 \ruleSpace T_1 \tinj T_2 = (T_1 \rel T_2)[\text{with } t, \text{ with } 1-, \text{ with } 1-_r]}
\end{prooftree}
\\
\tag{Relation Subtype - Partial Surjection}
\begin{prooftree}
\hypo{\Gamma \vdash set[T_1], set[T_2]}
\infer1{\Gamma \vdash T_1 \psur T_2 \ruleSpace T_1 \psur T_2 = (T_1 \rel T_2)[\text{with } t_r, \text{ with } 1-]}
\end{prooftree}
\\
\tag{Relation Subtype - Total Surjection}
\begin{prooftree}
\hypo{\Gamma \vdash set[T_1], set[T_2]}
\infer1{\Gamma \vdash T_1 \tsur T_2 \ruleSpace T_1 \tsur T_2 = (T_1 \rel T_2)[\text{with } t, \text{ with } t_r, \text{ with } 1-]}
\end{prooftree}
\\
\tag{Relation Subtype - Bijection}
\begin{prooftree}
\hypo{\Gamma \vdash set[T_1], set[T_2]}
\infer1{\Gamma \vdash T_1 \tbij T_2 \ruleSpace T_1 \tbij T_2 = (T_1 \rel T_2)[\text{with } t, \text{ with } t_r, \text{ with } 1-, \text{ with } 1-_r]}
\end{prooftree}
\end{gather}

\subsubsection{Simple Commands}
\paragraph{Includes:} Assignment, type assignment, type refinements, simple programming language commands/statements.

\begin{gather}
\tag{Variable Assignment}
\begin{prooftree}
\hypo{\Gamma \vdash E:A}
\hypo{I \not\in dom(\Gamma) \lor \Gamma \vdash I:A}
\infer2{\Gamma \vdash I:A := E }
\end{prooftree}
\\
\tag{Type Alias Assignment}
\begin{prooftree}
\hypo{\Gamma \vdash T}
\hypo{I \not\in dom(\Gamma)}
\infer2{\Gamma \vdash I := T }
\end{prooftree}
\\
\tag{Type Alias}
\begin{prooftree}
\hypo{\Gamma \vdash I := T}
\infer1{\Gamma, I \vdash \diamond \ruleSpace I = T}
\end{prooftree}
\\
\tag{Refined Variable Assignment}
\begin{prooftree}
\hypo{\Gamma \vdash E: A, E_1: A_1, ..., E_n:A_n}
\hypo{(I \not\in dom(\Gamma) \lor \Gamma \vdash I:A)}
\infer2{\Gamma \vdash I: A[\text{with } E_1: A_1, ..., \text{ with } E_n: A_n] := E}
\end{prooftree}
\\
\tag{Refined Type Alias}
\begin{prooftree}
\hypo{\Gamma \vdash T, E_1: A_1, ..., E_n: A_n}
\hypo{I \not\in dom(\Gamma)}
\infer2{\Gamma \vdash I := T[\text{with } E_1: A_1, ...,\text{ with } E_n: A_n]}
\end{prooftree}
\\
\tag{Command - break}
\begin{prooftree}
\hypo{\Gamma \vdash \diamond}
\infer1{\Gamma \vdash \text{break}: C}
\end{prooftree}
\\
\tag{Command - continue}
\begin{prooftree}
\hypo{\Gamma \vdash \diamond}
\infer1{\Gamma \vdash \text{continue}: C}
\end{prooftree}
\\
\tag{Command - skip}
\begin{prooftree}
\hypo{\Gamma \vdash \diamond}
\infer1{\Gamma \vdash \text{skip}: C}
\end{prooftree}
\\
\tag{Command - return}
\begin{prooftree}
\hypo{\Gamma \vdash E:A}
\infer1{\Gamma \vdash (\text{return } E): C}
\end{prooftree}
\end{gather}

\subsubsection{Quantification Expressions}
\paragraph{Includes:} Set, sequence, relation, and bag comprehensions, in addition to (set based) lambda expressions. Comprehension variables may be bound through either an $Identifier$ or an arbitrarily nested tuple of $Identifiers$

\begin{gather}
\tag{Lambda Expression}
\begin{prooftree}
\hypo{\Gamma \vdash E:A, P: bool}
\hypo{I_1:T_1, ..., I_n: T_n \text{ are vars in } E}
\infer2{\Gamma \vdash (\lambda I_1, ..., I_n \cdot P \mid E): (T_1, ..., T_n) \tfun A}
\end{prooftree}
\\
\tag{Quantification Body \footnote{where $TupleIdentifier$ is a recursive tuple of either $Identifier$s or nested $TupleIdentifiers$, $structuralMatch(e,T)$ is a recursive match between identifiers in $e$ and the set type $T$, $hasGenerator(P,e \in g)$ means the expression $e \in g$ occurs in one of the top-level OR/AND clauses, and $structuralMatchInAllORs(e, T, P)$ means all top-level OR clauses must see $e \in g$ for any $g$ with type $T$. For now, we may just force the generator to appear in the first clause of the predicate, where the predicate is a top-level AND.}}
\begin{prooftree}
\hypo{\begin{matrix}
\Gamma \vdash E:A, P:bool\\
I_1, ..., I_n: TupleIdentifier\\
% M_1, ..., M_n: MapletIdentifier\\
% L_1, ..., L_n: TupleIdentifier\\
Ids = \bagT{identifiers(I_i)}{0 \leq i \leq n}\\%identifier(L_i) \rrbracket\\ % \llbracket identifier(M_i) \rrbracket
\forall e \mapsto count \in Ids \cdot count = 1 \land e \not\in dom(\Gamma)\\
{\begin{split}
M = \{I_i \mapsto T \cdot &0 \leq i \leq n \\
    &\land \exists g \cdot \Gamma \vdash g: set[T] \\
    &\land structuralMatch(e, T) \\
    &\land hasGenerator(P, e \in g) \\
    &\land structuralMatchInAllORs(e, T, P)\}
\end{split}}\\
% \forall e \in I \cdot \exists (\Gamma \vdash g: set[T]) \cdot structuralMatch(e, T) \land appearsInTopLevelOrOf(e \in g, P)\\
% \forall I_i \cdot \exists g \cdot \Gamma \vdash g:set[T] \land P = ... \land I_i \in g \land ...\\
% \forall M_i \cdot (\exists g \cdot \Gamma \vdash T_1 \rel T_2 \land M_i \in g)\\
% \forall L_i \cdot \exists g \cdot \Gamma \vdash g: T_1 \rel ... \rel T_n \land P = ... L_i \in g ... \land n = len(L_i)
\end{matrix}}
\infer1{\Gamma \vdash (I_1, ..., I_n \cdot P \mid E): QuantificationBody[M,A]
% {\begin{split}
% \Gamma \vdash &(I_1, ..., I_n \cdot P \mid E): QuantificationBody[\\ %\cup M_i
% &\bSetT{e \mapsto T}{
% %(e\in I \land T = T_i)
% % \lor (e \in M_i \land T = T_i \rel T_j)
% e \in  \land T = T_i \rel ... \rel T_n}, A]
% \end{split}
% }
}
\end{prooftree}
% \frac{
% \splitfrac{
% \Gamma \vdash E:A, P:bool \ruleSpace I_1, ..., I_n: Identifier \ruleSpace M_1, ..., M_n: MapletIdentifier
% }{
%     \splitfrac{
%         L_1, ..., L_n: TupleIdentifier \ruleSpace I = \llbracket I_i \rrbracket + \llbracket identifier(M_i) \rrbracket + \llbracket identifier(L_i) \rrbracket
%     }{
%         \splitfrac{
%             \forall e \mapsto count \in I \cdot count = 1 \land e \in dom(\Gamma)
%         }{
%             \splitfrac{
%                 \forall I_i \cdot (\exists g \cdot \Gamma \vdash g:set[T] \land I_i \in g)
%             }{
%                \splitfrac{
%                     \forall M_i \cdot (\exists g \cdot \Gamma \vdash T_1 \rel T_2 \land M_i \in g)
%                 }{
%                     \forall L_i \cdot (\exists g \cdot \Gamma \vdash T_1 \rel T_2 \rel ... \rel T_n \land L_i \in g \land m = len(L_i)
%                 }
%             }
%         }
%     }
% }
% }
% {
% \splitfrac{
% \Gamma \vdash (I_i \cup M_i \cup L_i \cdot P \mid E): QuantificationBody[\{e \mapsto T \cdot (e\in I_i \land T = T_i)}{ \lor (e \in M_i \land T = T_i \rel T_j) \lor (e \in  L_i \land T = T_i \rel T_j \rel ... \rel T_n)\}, A]}
% }
\\
\tag{General Union}
\begin{prooftree}
\hypo{\Gamma \vdash (I \cdot P \mid E): QuantificationBody[M,A]}
\infer1{\Gamma \vdash (\bigcup I \cdot P \mid E): A}
\end{prooftree}
\\
\tag{General Intersection}
\begin{prooftree}
\hypo{\Gamma \vdash (I \cdot P \mid E): QuantificationBody[M,A]}
\infer1{\Gamma \vdash (\bigcap I \cdot P \mid E): A}
\end{prooftree}
\\
\tag{Forall}
\begin{prooftree}
\hypo{\Gamma \vdash (I \cdot P): QuantificationBody[M, bool]}
\infer1{\Gamma \vdash (\forall I \cdot P): bool}
\end{prooftree}
\\
\tag{Exists}
\begin{prooftree}
\hypo{\Gamma \vdash (I \cdot P): QuantificationBody[M, bool]}
\infer1{\Gamma \vdash (\exists I \cdot P): bool}
\end{prooftree}
\\
\tag{Set Comprehension}
\begin{prooftree}
\hypo{\Gamma \vdash (I \cdot P \mid E): QuantificationBody[M,A]}
\infer1{\Gamma \vdash \bSet{I}{P}{E}: set[A]}
\end{prooftree}
\\
\tag{Bag Comprehension}
\begin{prooftree}
\hypo{\Gamma \vdash (I \cdot P \mid E): QuantificationBody[M, A]}
\infer1{\Gamma \vdash \bag{I}{P}{E}: bag[A]}
\end{prooftree}
\\
\tag{Sequence Comprehension}
\begin{prooftree}
\hypo{\Gamma \vdash (I \cdot P \mid E): QuantificationBody[M, A]}
\infer1{\Gamma \vdash \List{I}{P}{E}: sequence[A]}
\end{prooftree}
\end{gather}

\subsubsection{Boolean Operations}
\paragraph{Includes:} Common predicate logic operations (equivalence, implication, and, or, etc.).

Let $\otimes = \{\equiv, \not\equiv, \implies, \land, \lor \}$

\begin{gather}
\tag{Binary Boolean Operations}
\begin{prooftree}
\hypo{\Gamma \vdash b_1, b_2: bool}
\infer1{\Gamma \vdash b_1 \otimes b_2 : bool}
\end{prooftree}
\\
\tag{Boolean Operations - Negation}
\begin{prooftree}
\hypo{\Gamma \vdash b_1: bool}
\infer1{\Gamma \vdash \lnot b_1 : bool}
\end{prooftree}
\end{gather}

\subsubsection{Equality and Membership}
\paragraph{Includes:} Equality and ordering comparisons, set membership.

Let $\otimes = \{=, \neq\}$

\begin{gather}
\tag{Equals}
\begin{prooftree}
\hypo{\Gamma \vdash a_1: T_1, a_2: T_2}
\infer1{\Gamma \vdash a_1 \otimes a_2 : bool}
\end{prooftree}
\end{gather}

Let $\otimes = \{<, \leq, >, \geq \}$

\begin{gather}
\tag{Ordering Operators}
\begin{prooftree}
\hypo{\Gamma \vdash a_1, a_2: T}
\hypo{T \in \{int, float, nat\}}
\infer2{\Gamma \vdash a_1 \otimes a_2 : bool}
\end{prooftree}
\end{gather}

Let $\otimes = \{\in, \not\in \}$

\begin{gather}
\tag{Set Membership}
\begin{prooftree}
\hypo{\Gamma \vdash a_1: T_1, a_2: set[T_2]}
\infer1{\Gamma \vdash a_1 \otimes a_2: bool}
\end{prooftree}
\end{gather}

\subsubsection{Set Operations}
\paragraph{Includes:} Subset comparisons, union, intersection, cartesian product, etc. Also includes Maplet and Range.

Let $\otimes = \{\subset, \subseteq, \supset, \supseteq, \not\subset, \not\subseteq, \not\supset, \not\supseteq \}$

\begin{gather}
\tag{Set Operations}
\begin{prooftree}
\hypo{\Gamma \vdash a_1: set[T_1], a_2: set[T_2]}
\infer1{\Gamma \vdash a_1 \otimes a_2: bool}
\end{prooftree}
\end{gather}

Let $\otimes = \{\cup, \cap, \setminus \}$

\begin{gather}
\tag{Set Operations}
\begin{prooftree}
\hypo{\Gamma \vdash a_1, a_2: set[T]}
\infer1{\Gamma \vdash a_1 \otimes a_2: set[T]}
\end{prooftree}
\\
\tag{Cartesian Product}
\begin{prooftree}
\hypo{\Gamma \vdash a_1: set[T_1], a_2: set[T_2]}
\infer1{\Gamma \vdash a_1 \times a_2: T_1 \rel T_2}
\end{prooftree}
\\
\tag{Maplet}
\begin{prooftree}
\hypo{\Gamma \vdash a_1: T_1, a_2: T_2}
\infer1{\Gamma \vdash a_1 \mapsto a_2: tuple[T_1, T_2]}
\end{prooftree}
\\
\tag{Numerical Range}
\begin{prooftree}
\hypo{\Gamma \vdash a_1, a_2: int}
\infer1{\Gamma \vdash a_1 \upto a_2: set[int, \text{ with } min = a_1, \text{ with } max = a_2]}
% Is max/min enough here? what if we union two ranges with dijoint max/mins
\end{prooftree}
\\
\tag{Set Operations - Powerset}
\begin{prooftree}
\hypo{\Gamma \vdash a:T}
\infer1{\Gamma \vdash \mathbb{P}(a):set[T]}
\end{prooftree}
\end{gather}

\subsubsection{Bag Operations}
\paragraph{Includes:} Bag union, bag intersection, etc.

Let $\otimes = \{\cup, \cap, +, -\}$
\begin{gather}
\tag{Bag Operations - (Max) Union}
\begin{prooftree}
\hypo{\Gamma \vdash a_1, a_2: bag[T]}
\infer1{\Gamma \vdash a_1 \otimes a_2: bag[T]}
\end{prooftree}
\\
\tag{Bag Operations - Image}
\begin{prooftree}
\hypo{\Gamma \vdash a: T_1 \rel T_2, b: bag[T_1]}
\infer1{\Gamma \vdash a[b]: bag[T_2] \ruleSpace a[b] = a^{-1} \circ b}
\end{prooftree}
\end{gather}

\subsubsection{Relation Operations}
\paragraph{Includes:} Relation overriding, composition, domain/range manipulation. See Section 5.1.3 for changes in relational subtypes after applying operations.

\begin{gather}
\tag{Relation Operations - Function Call}
\begin{prooftree}
\hypo{\Gamma \vdash a: T_1 \rel T_2, b:T_1}
\infer1{\Gamma \vdash  a(b):T_2}
\end{prooftree}
\\
\tag{Relation Operations - Image}
\begin{prooftree}
\hypo{\Gamma \vdash a: T_1 \rel T_2, b: set[T_1]}
\infer1{\Gamma \vdash a[b]: set[T_2]}
\end{prooftree}
\\
\tag{Relation Operations - Overriding}
\begin{prooftree}
\hypo{\Gamma \vdash a_1, a_2: T_1 \rel T_2}
\infer1{\Gamma \vdash a_1 \oplus a_2: T_1 \rel T_2}
\end{prooftree}
\\
\tag{Relation Operations - Composition}
\begin{prooftree}
\hypo{\Gamma \vdash a_1: T_1 \rel T_2, a_2: T_2 \rel T_3}
\infer1{\Gamma \vdash a_1 \circ a_2: T_1 \rel T_3}
\end{prooftree}
\\
\tag{Relation Operations - Domain Restriction}
\begin{prooftree}
\hypo{\Gamma \vdash a_1: T_1, a_2: T_1 \rel T_2}
\infer1{\Gamma \vdash a_1 \domres a_2: T_1 \rel T_2}
\end{prooftree}
\\
\tag{Relation Operations - Domain Subtraction}
\begin{prooftree}
\hypo{\Gamma \vdash a_1: T_1, a_2: T_1 \rel T_2}
\infer1{\Gamma \vdash a_1 \domsub a_2: T_1 \rel T_2}
\end{prooftree}
\\
\tag{Relation Operations - Range Restriction}
\begin{prooftree}
\hypo{\Gamma \vdash a_1: T_1 \rel T_2, a_2: T_2}
\infer1{\Gamma \vdash a_1 \ranres a_2: T_1 \rel T_2}
\end{prooftree}
\\
\tag{Relation Operations - Range Subtraction}
\begin{prooftree}
\hypo{\Gamma \vdash a_1: T_1 \rel T_2, a_2: T_2}
\infer1{\Gamma \vdash a_1 \ransub a_2: T_1 \rel T_2}
\end{prooftree}
\end{gather}

\subsubsection{Relational Subtypes After Operations}
\paragraph{Includes:} Changes in relational subtyping (totality, surjectivity, etc.) after applying operations.
For simplicity, we implement subtype changes in a few binary operators as a boolean mask representing: [with total ($t$), with total on range ($t_r$), with one-to-manyness ($1-$), with many-to-oneness ($1-_r$)]. Subtyping is done conservatively: we keep subtype properties only when they are guaranteed. See Section 5.1.3 for more on relational subtyping.

\begin{gather}
\tag{Relational Subtype - Domain Restriction}
\begin{prooftree}
\hypo{\Gamma \vdash s: set[T_1], r: (T_1 \rel T_2)[True, x, y, z]}
\infer1{\Gamma \vdash (s \domres r): (T_1 \rel T_2)[False, x, y, z]}
\end{prooftree}
\\
\tag{Relational Subtype - Domain Subtraction}
\begin{prooftree}
\hypo{\Gamma \vdash s: set[T_1], r: (T_1 \rel T_2)[True, x, y, z]}
\infer1{\Gamma \vdash (s \domsub r): (T_1 \rel T_2)[False, x, y, z]}
\end{prooftree}
\\
\tag{Relational Subtype - Range Restriction}
\begin{prooftree}
\hypo{\Gamma \vdash s: set[T_2], r: (T_1 \rel T_2)[x, True, y, z]}
\infer1{\Gamma \vdash (r \ranres s): (T_1 \rel T_2)[x, False, y, z]}
\end{prooftree}
\\
\tag{Relational Subtype - Range Subtraction}
\begin{prooftree}
\hypo{\Gamma \vdash s: set[T_2], r: (T_1 \rel T_2)[x, True, y, z]}
\infer1{\Gamma \vdash (r \ransub s): (T_1 \rel T_2)[x, False, y, z]}
\end{prooftree}
\\
\tag{Relational Subtype - Inverse}
\begin{prooftree}
\hypo{\Gamma \vdash r: (T_1 \rel T_2)[w, x, y, z]}
\infer1{\Gamma \vdash r^{-1}: (T_1 \rel T_2)[x, w, z, y]}
\end{prooftree}
\\
\tag{Relational Subtype - Overriding}
\begin{prooftree}
\hypo{\Gamma \vdash r: (T_1 \rel T_2)[a, b, c, d], t: (T_1 \rel T_2)[w, x, y, z]}
\infer1{\Gamma \vdash (r \oplus t): (T_1 \rel T_2)[w, x, c \land y, d \land z]}
\end{prooftree}
\\
\tag{Relational Subtype - Composition}
\begin{prooftree}
\hypo{\Gamma \vdash r: (T_1 \rel T_2)[a, b, c, d], t: (T_2 \rel T_3)[w, x, y, z]}
\infer1{\Gamma \vdash (r \circ t): (T_1 \rel T_3)[a, b \land x, c \land y, d \land z]}
\end{prooftree}
\end{gather}

\subsubsection{Sequence Operations}
\paragraph{Includes:} Concatenation

\begin{gather}
\tag{Sequence Operations - Concatenation}
\begin{prooftree}
\hypo{\Gamma \vdash a_1, a_2: sequence[T]}
\infer1{\Gamma \vdash a_1 \concat a_2: sequence[T]}
\end{prooftree}
\end{gather}

\subsubsection{Numerical Operations}
\paragraph{Includes:} Addition, subtraction, multiplication, etc. on natrual numbers, integers, and floats.

\begin{gather}
\tag{Integer Operations - Division}
\begin{prooftree}
\hypo{\Gamma \vdash a_1: T_1, a_2: T_2}
\hypo{T_i \in \{int, nat\}}
\infer2{\Gamma \vdash a_1 \text{ div } a_2: max(T_1, T_2)}
\end{prooftree}
\\
\tag{Integer Operations - Modulo}
\begin{prooftree}
\hypo{\Gamma \vdash a_1: T_1, a_2: T_2}
\hypo{T_i \in \{int, nat\}}
\infer2{\Gamma \vdash a_1 \text{ mod } a_2: max(T_1, T_2)}
\end{prooftree}
\\
\tag{Numerical Operations - Addition}
\begin{prooftree}
\hypo{\Gamma \vdash a_1: T_1, a_2: T_2}
\hypo{T_i \in \{int, nat, float\}}
\infer2{\Gamma \vdash a_1 + a_2: max(T_1, T_2)}
\end{prooftree}
\\
\tag{Numerical Operations - Subtraction}
\begin{prooftree}
\hypo{\Gamma \vdash a_1: T_1, a_2: T_2}
\hypo{T_i \in \{int, nat, float\}}
\infer2{\Gamma \vdash a_1 - a_2: max(T_1, T_2, int)}
\end{prooftree}
\\
\tag{Numerical Operations - Floating Division}
\begin{prooftree}
\hypo{\Gamma \vdash a_1: T_1, a_2: T_2}
\hypo{T_i \in \{int, nat, float\}}
\infer2{\Gamma \vdash a_1 * a_2: float}
\end{prooftree}
\\
\tag{Numerical Operations - Multiplication}
\begin{prooftree}
\hypo{\Gamma \vdash a_1: T_1, a_2: T_2}
\hypo{T_i \in \{int, nat, float\}}
\infer2{\Gamma \vdash a_1 \text{ div } a_2: max(T_1, T_2)}
\end{prooftree}
\\
\tag{Numerical Operations - Negation}
\begin{prooftree}
\hypo{\Gamma \vdash a_1: T}
\hypo{T \in \{int, nat, float\}}
\infer2{\Gamma \vdash -a_1: max(int, T)}
\end{prooftree}
\\
\tag{Numerical Operations - Exponentiation}
\begin{prooftree}
\hypo{\Gamma \vdash a_1: T_1, a_2: T_2}
\hypo{T_i \in \{int, nat, float\}}
\infer2{\Gamma \vdash a_1 \text{ \^{} } a_2: max(T_1, T_2)}
\end{prooftree}
\end{gather}

\subsubsection{Record Types}
\paragraph{Includes:} Types for named tuples.

\begin{gather}
\tag{Records - Access}
\begin{prooftree}
\hypo{\Gamma \vdash a: Record[I:A, ...]}
\infer1{\Gamma \vdash a.I: A}
\end{prooftree}
\\
\tag{Records - Type Definition}
\begin{prooftree}
\hypo{\Gamma \vdash A_1, ..., A_n}
\hypo{\forall I_i, I_j \cdot I_i \neq I_j}
\infer2{\Gamma \vdash Record[I_1: A_1, ..., I_n: A_n]}
\end{prooftree}
\\
\tag{Records - Initialization}
\begin{prooftree}
\hypo{\Gamma \vdash a_1: A_1, ..., a_n: A_n}
\infer1{\Gamma \vdash record(a_1=A_1, ..., a_n=A_n): Record[a_1: A_1, ..., a_n:A_n]}
\end{prooftree}
\end{gather}

\subsubsection{Compound Commands}
\paragraph{Includes:} If, While, For, and Import statements, along with Procedure definitions and calls.

\begin{gather}
\tag{Command - Composition}
\begin{prooftree}
\hypo{\Gamma \vdash C_1, C_2}
\infer1{\Gamma \vdash C_1 \text{ \textbackslash n } C_2}
\end{prooftree}
\\
\tag{Command - Valid Import Module}
\begin{prooftree}
\hypo{\Gamma \vdash \diamond}
\infer1{\Gamma \vdash \text{import } M: C}
\end{prooftree}
\\
\tag{Command - Valid Import Names}
\begin{prooftree}
\hypo{\Gamma \vdash \diamond}
\infer1{\Gamma \vdash \text{from } M \text{ import } I_1, ..., I_n: C}
\end{prooftree}
\\
\tag{Command - Import Module}
\begin{prooftree}
\hypo{\Gamma \vdash \text{import } M \text{ (with identifiers and types } I_1: A_1, ..., I_n: A_n)}
\infer1{\Gamma, M=record(I_1=A_1, ..., I_n=A_n) \vdash \diamond}
\end{prooftree}
\\
\tag{Command - Import Names}
\begin{prooftree}
\hypo{\Gamma \vdash \text{from } M \text{ import } I_1, ..., I_n \text{ (with types } A_1, ..., A_n)}
\infer1{\Gamma, I_1:A_1, ..., I_n:A_n \vdash \diamond}
\end{prooftree}
\\
\tag{Command - Procedure Definition}
\begin{prooftree}
\hypo{\Gamma \vdash C, E, A_1, ..., A_n}
\infer1{\Gamma \vdash \text{ procedure }I=C \therefore I: procedure[A_1, ..., A_n, E]}
\end{prooftree}
\\
\tag{Command - Procedure Call}
\begin{prooftree}
\hypo{\Gamma \vdash procedure[A_1, ..., A_n, E], a_1: A_1, ..., a_n:A_n}
\infer1{\Gamma \vdash I(a_1, ..., a_n): E}
\end{prooftree}
\\
\tag{Command - If}
\begin{prooftree}
\hypo{\Gamma \vdash C, b: bool}
\infer1{\Gamma \vdash \text{if } b: C}
\end{prooftree}
\\
\tag{Command - If Else}
\begin{prooftree}
\hypo{\Gamma \vdash C_1, C_2, b: bool}
\infer1{\Gamma \vdash \text{if } b: C_1 \text{ else}: C_2}
\end{prooftree}
\\
\tag{Command - While}
\begin{prooftree}
\hypo{\Gamma \vdash C, b: bool}
\infer1{\Gamma \vdash \text{while } b: C}
\end{prooftree}
\\
\tag{Command - For}
\begin{prooftree}
\hypo{\Gamma \vdash C, p: bool}
\hypo{p = i \in G}
\infer2{\Gamma \vdash \text{for } p: C}
\end{prooftree}
\\
\tag{Command - Block}
\begin{prooftree}
\hypo{\Gamma \vdash D \therefore I:A}
\hypo{\Gamma, I:A \vdash C}
\infer2{\Gamma \vdash C \text{ substitute vars in } D}
\end{prooftree}
\end{gather}



\subsubsection{Built-in Functions}
\paragraph{Includes:} Common set-related functions.

\begin{gather}
\tag{Built-in - Minimum}
\begin{prooftree}
\hypo{\Gamma \vdash T[\text{with } order \in traits(T)]}
\infer1{\Gamma \vdash min: set[T] \rightarrow T}
\end{prooftree}
\\
\tag{Built-in - Mapped Minimum}
\begin{prooftree}
\hypo{\Gamma \vdash T, int}
\infer1{\Gamma \vdash min: set[T] \times (T \rightarrow int) \rightarrow T}
\end{prooftree}
\\
\tag{Built-in - Maximum}
\begin{prooftree}
\hypo{\Gamma \vdash T[\text{with } order \in traits(T)]}
\infer1{\Gamma \vdash max: set[T] \rightarrow T}
\end{prooftree}
\\
\tag{Built-in - Mapped Maximum}
\begin{prooftree}
\hypo{\Gamma \vdash T, int}
\infer1{\Gamma \vdash max: set[T] \times (T \rightarrow int) \rightarrow T}
\end{prooftree}
\\
\tag{Built-in - Choice}
\begin{prooftree}
\hypo{\Gamma \vdash T}
\infer1{\Gamma \vdash choice: set[T] \rightarrow T}
\end{prooftree}
\\
\tag{Built-in - Domain}
\begin{prooftree}
\hypo{\Gamma \vdash T}
\infer1{\Gamma \vdash dom: T_1 \rel T_2 \rightarrow set[T_1]}
\end{prooftree}
\\
\tag{Built-in - Range}
\begin{prooftree}
\hypo{\Gamma \vdash T}
\infer1{\Gamma \vdash ran: T_1 \rel T_2 \rightarrow set[T_2]}
\end{prooftree}
\\
\tag{Built-in - Cardinality}
\begin{prooftree}
\hypo{\Gamma \vdash T}
\infer1{\Gamma \vdash card: set[T] \rightarrow nat}
\end{prooftree}
\\
\tag{Built-in - Bag Size}
\begin{prooftree}
\hypo{\Gamma \vdash T}
\infer1{\Gamma \vdash size: bag[T] \rightarrow nat}
\end{prooftree}
\\
\tag{Built-in - Sum}
\begin{prooftree}
\hypo{\Gamma \vdash T}
\hypo{T \in \{int, float, nat\}}
\infer2{\Gamma \vdash sum: set[T] \rightarrow T}
\end{prooftree}
\\
\tag{Built-in - Cast}
\begin{prooftree}
\hypo{\Gamma \vdash T_1, T_2}
\infer1{\Gamma \vdash cast: type[T_1] \times T_1 \rightarrow T_2}
\end{prooftree}
\\
\tag{Built-in - Cast With \footnote{$E$ represents `with' expressions to tag onto a type}}
\begin{prooftree}
\hypo{\Gamma \vdash T_1, T_2, x: E}
\infer1{\Gamma \vdash cast: type[T_1] \times T_1 \times set[E] \rightarrow T_2[\text{with } x: E]}
\end{prooftree}
\end{gather}

\subsection{Static Analysis - Type System Extensions with Traits}

\subsubsection{Trait-trait interactions}
Collection of trait-implies-trait interactions that are universal (i.e., they do not depend on a type). Most traits are really just boolean values, as in, does this type have this property. Thus when traits used with boolean operations should be interpreted as truthy/falsy.

Interpret these as if it were type initialization. So, if a type were initialized with these traits, we would get the following implications ``for-free''. A type can only have one of each trait (except for multiple literals?), so traits given in the assumption can be used in the result without ambiguity or naming. Traits with function notation (parenthesis) are assumed to be new constructions.

TODO design decision: should traits be applied automatically or just verified? If we apply automatically, we could give best effort and then error/remove traits that are incompatible. In verification, we just throw an error. We may use trait restrictions per-type to further determine incompatibilities (ex. an integer cannot be empty?).

\begin{gather}
  \tag{Literal Empty}
  \begin{prooftree}
    \hypo{LiteralTrait.values = []}
    \infer1{\lnot LiteralTrait}
  \end{prooftree}
  \\
  \tag{Domain Empty}
  \begin{prooftree}
    \hypo{DomainTrait.values = []}
    \infer1{\lnot DomainTrait}
  \end{prooftree}
  \\
  \tag{Literal implies a Domain}
  \begin{prooftree}
    \hypo{LiteralTraits}
    \hypo{\lnot DomainTrait}
    \infer2{DomainTrait(LiteralTraits)}
  \end{prooftree}
  \\
  \tag{Literals within Domain}
  \begin{prooftree}
    \hypo{LiteralTraits}
    \hypo{DomainTrait}
    \infer2{DomainTrait(DomainTrait + LiteralTraits)}
  \end{prooftree}
  \\
  \tag{Orderable Domain without Min}
  \begin{prooftree}
    \hypo{DomainTrait}
    \hypo{OrderableTrait}
    \hypo{\lnot MinTrait}
    \infer3{MinTrait(min(DomainTrait))}
  \end{prooftree}
  \\
  \tag{Orderable Domain with Min}
  \begin{prooftree}
    \hypo{DomainTrait}
    \hypo{OrderableTrait}
    \hypo{MinTrait}
    \infer3{MinTrait(min(MinTrait, DomainTrait))}
  \end{prooftree}
  \\
  \tag{Orderable Domain without Max}
  \begin{prooftree}
    \hypo{DomainTrait}
    \hypo{OrderableTrait}
    \hypo{\lnot MaxTrait}
    \infer3{MaxTrait(max(DomainTrait))}
  \end{prooftree}
  \\
  \tag{Orderable Domain with Max}
  \begin{prooftree}
    \hypo{DomainTrait}
    \hypo{OrderableTrait}
    \hypo{MaxTrait}
    \infer3{MaxTrait(max(MaxTrait, DomainTrait))}
  \end{prooftree}
  \\
  \tag{Min implies Order}
  \begin{prooftree}
    \hypo{MinTrait}
    \infer1{OrderableTrait}
  \end{prooftree}
  \\
  \tag{Max implies Order}
  \begin{prooftree}
    \hypo{MaxTrait}
    \infer1{OrderableTrait}
  \end{prooftree}
  \\
  \tag{Full set}
  \begin{prooftree}
    \hypo{UniqueElementsTrait}
    \hypo{SizeTrait = len(DomainTrait)}
    \hypo{\lnot EmptyTrait} % could an empty set be total if its domain consists of nothing? what is this a set of?
    \infer3{TotalTrait}
  \end{prooftree}
  \\
  \tag{Empty Size}
  \begin{prooftree}
    \hypo{SizeTrait = 0}
    \infer1{EmptyTrait}
  \end{prooftree}
  \\
  \tag{Non-Empty Size}
  \begin{prooftree}
    \hypo{SizeTrait \neq 0}
    \infer1{\lnot EmptyTrait}
  \end{prooftree}
  \\
  \tag{Size implies Iterable}
  \begin{prooftree}
    \hypo{SizeTrait}
    \infer1{IterableTrait}
  \end{prooftree}
  \\
  \tag{Unknown value clears literals TODO move this to the operation section TODO add unknown trait so we can keep domain + unknown? Could help some values...}
  \begin{prooftree}
    \hypo{LiteralTraits}
    \hypo{unknown\_operation}
    \infer2{\lnot LiteralTraits}
  \end{prooftree}
\end{gather}

\subsubsection{Type-trait interactions}
Some types are incompatible with some traits, some types must have some traits. This section lists the possible traits for each type.

Asterisks are for mandatory traits. Traits not listed are not allowed.

All types:
\begin{itemize}
  \item ImmutableTrait
  \item LiteralTraits
  \item DomainTrait
\end{itemize}

Bool:
\begin{itemize}
  \item DomainTrait(true, false)*
\end{itemize}

None:
\begin{itemize}
  \item LiteralTrait*
  \item Domain? (implied from literal)
\end{itemize}

String:
\begin{itemize}
  \item Empty
  \item Size (length)
  \item Unique?
  \item Iterable*
  \item Orderable (lexicographic)*
\end{itemize}

Int, Float:
\begin{itemize}
  \item Min
  \item Max
  \item Size (num of bits? or just depend on min/max? If so, min/max must be given, with a default value of 64 bit range)
  \item Iterable*
  \item Orderable*
\end{itemize}

Tuple:
\begin{itemize}
  \item Min
  \item Max
  \item Size (length)
  \item UniqueElements
  \item Total
  \item Iterable*
  \item Orderable (lexicographic if dependents are orderable?)
\end{itemize}

Maplet: Tuple but with:
\begin{itemize}
  \item Domain?
  \item Size = 2*
\end{itemize}

Record:
\begin{itemize}
  \item Iterable* (treat as a relation)
  \item Domain* (str entries)
  \item ManyToOne* (treat as a relation with keys = strings)
\end{itemize}

Procedure:
\begin{itemize}
  \item Domain should be stored in the domain of the input types since there are too many to count? Range should be the domain of the return type
  \item Need to worry about generics?
\end{itemize}

Set:
\begin{itemize}
  \item Orderable if children are
  \item Min
  \item Max
  \item Iterable*
  \item Empty
  \item UniqueElements*
  \item Size
  \item Total
\end{itemize}

Relation: all traits except generic trait

Bag: same as relation, with ManyToOne*. Should we add a trait called Count, which is the sum of the range values?

Seq: same as relation, with ManyToOne*, Size*

Enum:
\begin{enumerate}
  \item Immutable*
  \item Domain*
  \item Literal*
  \item Iterable*
  \item UniqueELements*
  \item Size*?
  \item Can never be total unless enum size = 1, then always total
\end{enumerate}

% TODO add in semantics for "with"-clause interactions

\subsection{Definedness}
% Operators that can be undefined:
% - division by 0
% - function on an empty set, simplifies to choice of image
% - all non-equality operations with undefined as an input is undefined
% - complex numbers?
% - 0^0?
% the event b guide specifies short circuited ands for definedness, but they probably dont swap ands in optimization... we should try two different ways: either all and clauses must be defined or we attempt to recover from undefined clauses when seen
% Functions that can be undefined:
% - choice on empty set (undefined with a given type)

\subsection{Language Examples} % Move to motivation?
\section{Features and Behaviours}
\section{User-Facing Specification}
% Non-determinism, short circuiting

\subsection{(Abstract) Data Types}
For the most part, Simile's semantics resemble those of set theory and specification languages (specifically, Event-B). Aside from a few primitive types that abstract over bare set theory and programming language specific structures, like integer arithmetic and procedure definitions, all objects inherit properties from sets. For example, a sequence can be modelled as a set of pairs from natural numbers to the sequence element type.

In the forthcoming sections, we explicitly state the design of these set-theory-inspired types, useful properties, and underlying implementations.

\subsubsection{Primitives}
With consideration to execution efficiency and the extensive amount of existing optimization in modern languages, Simile makes use of the following basic types:
\begin{description}
    \item[Booleans] As the cornerstone of logical reasoning, booleans deserve an explicit type with reserved identifiers: $\mathbb{B} = \{True, False\}$. Further, Simile provides a healthy supply of common operations beyond $\land$ and $\lor$: $\implies, \equiv, \impliedby, \forall, \exists,$ etc.
    \item[Integers] While integers are a very mature type in the world of computing, trade-offs between arbitrary-precision and fixed-point arithmetic may require testing and careful review.
    \\
    If Simile chooses to represent numbers through conventional fixed point arithmetic, struggles with overflow and extremely large numbers are compounded by the innate non-determinism within Simile. For example, calculating the sum of a set of very large numbers can be done in arbitrary order, according to the semantics of mathematics (and Simile). But in fixed-point arithmetic, the resulting value can very well differ based on the order of operations. In other words, commutative math operations are no longer commutative under fixed precision. At some point in the computation pipeline, Simile will need to decide the order in which to evaluate the set, which may cause hard-to-spot bugs and unexpected runtime failures.
    \\
    Conversely, choosing arbitrary precision integers may bring Simile operators closer to mathematics at the cost of speed. The core features of Simile, while targeting formal methods users, attempt to efficiently execute set and relation operations. Adding checks for overflow on every mathematical operation may prove detrimental to performance.
    \\
    The implementation decision essentially is one of context vs. safety. To benchmark Simile with these types, we gather a list of examples and judge whether the performance hit is worth the reliability benefits. Specific questions to examine: How often does overflow occur in these examples? Do numbers approach the upper limits of fixed precision often enough to warrant accommodating infrastructure? What is the performance of fixed vs. arbitrary precision calculations.
    \item[Floating Point Numbers] In a similar vein to integers, floats are an imperfect translation of real numbers into efficiently calculable representations. Since floats (or even reals) are not used as often in specifications as integers, we leave the implementation as the conventional 64-bit representation. However, we note that non-determinism on these operations will prove especially tricky, since the result of commutative complements may differ without explicit over/underflow.
    \item[Strings] Strings are syntactic sugar over Sequences of characters, represented internally as a sequence of (fixed precision) integers. Eventually, Simile aims to support built-in string operations as seen in many common programming languages.
\end{description}

\subsubsection{Sets}
Foundational Simile type: an unordered, unique collection of objects.

Sets may be used in two ways:
\begin{enumerate}
    \item Enumerations by way of $\{x,y,z\}$ (read: The set of elements $x,y$, and $z$)
    \item Comprehensions of the form $\bSet{x}{x \in S}{f(x)}$ (read: The set of function $f$ applied to all elements in $S$). A small effort is made to accommodate a shorthand form, wherein $\bSet{x}{x \in S}{x}$ may be written as $\bSetT{x}{x \in S}$, but this syntax easily confuses bound/unbound variables and is not recommended for complex comprehension expressions.
\end{enumerate}

Sets, as mathematical objects with only two major restrictions, lend themselves well to a variety of computational implementations. Arrays, ordered arrays, hash maps, bit sets, roaring bit sets, path maps, and tries can all be used to satisfy the uniqueness property and hide an internally ordered representation from users.

% Arrays, heaps, hashmaps, bitsets, roaring bitsets, pathmaps, tries?

No matter the underlying implementation, the optimizer may make use of syntactically-analyzed set sizes to direct the choice of lowered iterator. Further, recording the cardinality of a set at runtime may prove beneficial to the performance of common cardinality-based specification expressions at a very small memory cost. Other properties based on element type, like max/min for numeric types, limits for numeric ranges, maximum sizes, may be useful.


\subsubsection{Relations}
Relations are sets that make use of paired/maplet elements (i.e., they define a relationship between two sets). Like sets, implementations may vary greatly, with the potential to increase efficiency of relation-specific operations.

% Array of tuples, bimaps, bimaps with lists, bimaps with pointers, pathmaps, tries?

Like sets, relations may benefit from compile-time computed properties: size of the domain, size of the range, totality, many-to-oneness, $O(1)$ access to the domain and range, and access to associated domain/range properties.


% Once everything is settled, see about theorem provers, HOL/Lean, to force correct handling of definedness


% TODO add a section discussion nondeterminism, operator behaviour, justification, etc.

\paragraph{Relational Subtypes}
The notion of a relation is a broad classification of a set of pairs, where the domain, range, and relationship are not bound by any conditions. However, when generating code based on purely mathematical relations, it can be advantageous to use notions of totality, injectivity, surjectivity, etc. In particular, these named relational subtypes can be described with four properties: total on the domain, total on the range, one-to-many, and many-to-one.

The below table converts conventional notation into these four subtypes:
\begin{table}[H]
  \centering\begin{tabular}{|c|c|c|c|c|}
    \hline
    Relational Subtype & \multicolumn{4}{c|}{Properties}\\
    & T & TR & 1- & 1-R\\
    \hline
    Relation & & & & \\
     & & & & \checkmark \\
    Partial Function & & & \checkmark & \\
    Partial Injection & & & \checkmark & \checkmark \\
    Surjective Relation & & \checkmark & & \\
     & & \checkmark & & \checkmark \\
    Partial Surjection & & \checkmark & \checkmark & \\
     & & \checkmark & \checkmark & \checkmark \\
    Total Relation & \checkmark & & & \\
     & \checkmark & & & \checkmark \\
    Total Function & \checkmark & & \checkmark & \\
    Total Injection & \checkmark & & \checkmark & \checkmark \\
    Total Surjective Relation & \checkmark & \checkmark & & \\
     & \checkmark & \checkmark & & \checkmark \\
    Total Surjection & \checkmark & \checkmark & \checkmark & \\
    Bijection & \checkmark & \checkmark & \checkmark & \checkmark \\
    % Relation & \\
    % Total Relation & T \\
    % Surjective Relation & TR \\
    % Total Surjective Relation & T, TR \\
    % Partial Function & 1-\\
    % Total Function & T, 1-\\
    % Partial Injection & 1-, 1-R\\
    % Total Injection & T, 1-, 1-R\\
    % Partial Surjection & TR, 1-\\
    % Total Surjection & T, TR, 1-\\
    % Bijection & T, TR, 1-, 1-R\\
    % Should we consider Partial Bijection too?
    % Partial Bijection  & \\
    \hline
  \end{tabular}
  \caption{Conventional mathematical notation of relational subtypes decomposed into four properties: domain totality (T), range totality (TR), domain one-to-manyness (1-), and range one-to-manyness (1-R)}
  \label{tab:relSubtype}
\end{table}

\paragraph{Subtype Properties}
Properties that can affect code generation may involve:
\begin{itemize}
  \item New properties after applying operations on sets/relations
  \item Size of result
  \item Validity of operations
  \item Deterministic nature of operations
  \item Super/subset properties
  \item Relational identities
\end{itemize}
%
Below is a list of the impact of these properties.
\\
Domain Totality:
\begin{itemize}
  \item $R[S] \neq \emptyset$
  \item $R(S)$ is always valid
  \item $R^{-1}$ is TR
  \item $|R| \geq dom(R)$
\end{itemize}
%
Range Totality:
\begin{itemize}
  \item $R^{-1}$ is T
  \item $|R| \geq ran(R)$
\end{itemize}
%
Domain One-to-manyness:
\begin{itemize}
  \item $R(\{e\})$ is deterministic
  \item $|R[\{e\}]| = 1$
  \item $|R[S]| \leq |S|$
  \item $|R| \leq dom(R)$
\end{itemize}
%
Range One-to-manyness:
\begin{itemize}
  \item $|R| \leq ran(R)$
\end{itemize}

\subsubsection{Bags}
Bags (or Multisets) are a refinement of relations wherein, for a bag with element type $T$, the bag is a relational function from $T \rightarrow \mathbb{Z}^+$, denoting the count of items in a collection. Once the count of an item reaches 0, the item is removed from the bag.

Bags must be many-to-one and carry specialized behaviours for conventional relation operations. For example, relational image ($R[B]$) with a bag argument will now return a bag, where the number of occurrences of the resulting item replaces what would otherwise be a regular set of those items.

Additional fields to record the size of the bag (sum of the range) may prove useful.

\subsubsection{Sequences}
Sequences are yet another refinement of relations where a sequence with element type $T$ represents a relational function from $\mathbb{N} \rightarrow T$ that is total on some defined bounds.

The dense nature of sequence domains, along with knowledge of sequence sizes, may open up further data type refinements.

\subsection{Data Type Operations}
\subsubsection{Primitives}
\subsubsection{Sets}
\subsubsection{Relations}
\subsubsection{Bags}
\subsubsection{Sequences}

\section{Implementation Specification}
\subsection{Abstract Data Types}
\subsection{Atomic Operations}
\subsection{Optimization Frontend}
\subsection{Optimization Backends}

\section{AST Lowering and Optimization Rules}
Below is a list of rewrite rules for key abstract data types, syntactic sugar, and some builtin functions. Phases are intended to be executed in order; the post-condition of one phase serves as the pre-condition for the next.

\subsection{Syntactic Sugar for Bags}
\begin{align}
  \tag{Bag Image}
  R[B]
  &\leadsto
  R^{-1} \circ B
  \\
  \tag{Bag Predicates - Union}
  S \cup T &\leadsto \bag{x}{x \in dom(S) \cup dom(T) \land n = max(S[x] \cup T[x])}{x \mapsto n}
  \\
  \tag{Bag Predicates - Intersection}
  S \cap T &\leadsto \bag{x}{x \in dom(S) \cap dom(T) \land n = min(S[x] \cup T[x]) \land n > 0}{x \mapsto n}
  \\
  \tag{Bag Predicates - Sum}
  S + T &\leadsto \bag{x}{x \in dom(S) \cup dom(T) \land n = sum(S[x] \cup T[x])}{x \mapsto n}
  \\
  \tag{Bag Predicates - Difference}
  % S - T &\leadsto \bag{x}{x \in dom(S) \land pop(S[x]) - popDefault(T[x], 0) \land n > 0}{x \mapsto n}
  S - T &\leadsto \bag{x}{x \in dom(S) \land n = S(x) - (T \cup \llbracket x \mapsto 0\rrbracket)(x) \land n > 0}{x \mapsto n}
\end{align}

\subsection{Syntactic Sugar for Sequences}
\begin{align}
    \tag{Concatenation}
    L \concat M
    &\leadsto
    L \cup \bSet{x \mapsto y}{x \mapsto y \in M }{x + max(dom(L)) \mapsto y}
    \\
    \tag{Flatten}
    flatten(X)
    &\leadsto
    foldL(\concat, [], X)
    \\
    \tag{Fold Left Associative}
    foldL(f, e, X)
    &\leadsto
    foldL(f, f(e, first(X)), tail(X))
    \\
    \tag{Fold Left Associative - Empty}
    foldL(f, e, [])
    &\leadsto
    e
    \\
    \tag{First}
    first(X)
    &\leadsto
    X(0)
    \\
    \tag{Tail}
    tail(X)
    &\leadsto
    \bSet{i \mapsto x}{i \mapsto x \in X \land i \neq 0}{i-1 \mapsto x}
    \\
    \tag{Append}
    append(X, y)
    &\leadsto
    X \cup \{max(dom(X)) \mapsto y\}
    \\
    \tag{Prepend}
    prepend(X, y)
    &\leadsto
    \bSet{i \mapsto x}{i \mapsto x \in X}{i+1 \mapsto x} \cup {0 \mapsto y}
\end{align}
\subsection{Builtin Functions}

\noindent\begin{minipage}{\linewidth}
\begin{align}
  \tag{Functional Override}
  f(x) := E
  &\leadsto
  f := f \oplus \{x \mapsto E\}
  \\
  \tag{Cardinality}
  card(S)
  &\leadsto
  \sum x \cdot x \in S \mid 1
  \\
  \tag{Domain}
  dom(R)
  &\leadsto
  \bSet{x \mapsto y}{x \mapsto y \in R}{x}
  \\
  \tag{Range}
  ran(R)
  &\leadsto
  \bSet{x \mapsto y}{x \mapsto y \in R}{y}
  \\
  \tag{Override}
  R \oplus Q &\leadsto Q \cup (dom(Q) \domsub R)
  \\
  \tag{Domain Restriction}
  S \triangleleft R &\leadsto \bSet{x\mapsto y}{x \mapsto y \in R \land x \in S}{x \mapsto y}
  \\
  \tag{Domain Subtraction}
  S \domsub R &\leadsto \bSet{x\mapsto y}{x \mapsto y \in R \land x \notin S}{x \mapsto y}
  \\
  \tag{Range Restriction}
  R \triangleright S &\leadsto \bSet{x\mapsto y}{x \mapsto y \in R \land y \in S}{x \mapsto y}
  \\
  \tag{Range Subtraction}
  R \ransub S &\leadsto \bSet{x\mapsto y}{x \mapsto y \in R \land y \notin S}{x \mapsto y}
   \\
  \tag{Bag Size}
  size(S) &\leadsto \sum x \mapsto n \in S \cdot n
\end{align}
\end{minipage}

\subsection{Comprehension Construction}

\paragraph{Intuition} All set-like variables and literals are decomposed into set comprehensions.

\paragraph{Post-condition}
\begin{itemize}
  \item All terms with a set-like type (relations, bags, sets, sequences, etc.) must be in comprehension form.
\end{itemize}


\noindent\begin{minipage}{\linewidth}
\begin{align}
  \tag{Functional Image \footnote{May fail if R is not total. $choice$ is nondeterministic.}}
  R(x) &\leadsto choice(R[x])
  \\ % dont use pop - random choice but pop(S) == pop(S). Python op is completely nondeterministic so it may not return the same one R(x) = small epsilon y . y in R[{x}]
  % if R[{x}] is empty, you return "an arbitrary element of range of R", not None
  \tag{Image}
  R[S] &\leadsto \bSet{x \mapsto y}{x \mapsto y \in R \land x \in S}{y}
  \\
  \tag{Product}
  x \mapsto y \in S \times T &\leadsto x \in S \land y \in T
  \\
  \tag{Inverse}
  x \mapsto y \in R^{-1} &\leadsto y \mapsto x \in R
  \\
  \tag{Composition}
  x \mapsto y \in (Q \circ R) &\leadsto x \mapsto z \in Q \land z' \mapsto y \in R \land z=z'
  % \tag{Exists Elimination}
  % \exists z \cdot x \mapsto z \in Q \land z \mapsto y \in R &\leadsto x \mapsto z \in Q \land z' \mapsto y \in R \land z=z'
  % \\
  \end{align}
\end{minipage}
\noindent\begin{minipage}{\linewidth}
\begin{align}
  \tag{Predicate Operations - Union}
  S \cup T
  &\leadsto
  \bSetT{x}{x \in S \lor x \in T}
  \\
  \tag{Predicate Operations - Intersection}
  S \cap T
  &\leadsto
  \bSetT{x}{x \in S \land x \in T}
  \\
  \tag{Predicate Operations - Difference}
  S \setminus T
  &\leadsto
  \bSetT{x}{x \in S \land x \notin T}
  % \\
  % \tag{Singleton Membership \footnote{Currently unused. We need to be careful to handle the case where $x$ is a free variable.}}
  % x \in \{e\}
  % &\leadsto
  % x = e
  \\
  \tag{Membership Collapse \footnote{Rule only matches inside the predicate of a quantifier. Explicitly enumerating all matches for all quantuantification types and predicate cases (ANDs, ORs, etc.) would require too much boilerplate. $x$ must be bound by the encasing quantifier.\\
  The $\oplus$ operator represents any quantifier that returns a set-like type (ex. generalized union/intersection, set comprehension, relation comprehension).}}
  x \in \oplus(E \mid P)
  &\leadsto
  P \land x = E
\end{align}
\end{minipage}

\subsection{Disjunctive Normal Form}

\paragraph{Intuition} All quantifier predicates are expanded to DNF (i.e. $\land$-operations nested within top-level $\lor$-operations).

\paragraph{Notes} All matches of this phase occur only inside quantifier predicates.

\paragraph{Post-condition}
\begin{itemize}
  \item All terms with a set-like type (relations, bags, sets, sequences, etc.) must be in comprehension form.
  \item Quantifier predicates are in disjunctive normal form - top level or-clauses with inner and-clauses.
  \item If no $\lor$ operators exist within a quantifier predicate, the predicate must only contain $\land$ operators.
\end{itemize}

% https://en.wikipedia.org/wiki/Disjunctive_normal_form
\noindent\begin{minipage}{\linewidth} % Need minipage for footnote
\begin{align}
  \tag{Flatten Nested $\land$}
  x_1 \land ... \land (x_i \land x_{i+1}) \land ...
  &\leadsto
  x_1 \land ... \land x_i \land x_{i+1} \land ...
  \\
  \tag{Flatten Nested $\lor$}
  x_1 \lor ... \lor (x_i \lor x_{i+1}) \lor ...
  &\leadsto
  x_1 \lor ... \lor x_i \lor x_{i+1} \lor ...
  \\
  \tag{Double Negation}
  \lnot \lnot x
  &\leadsto
  x
  \\
  \tag{Distribute De Morgan - Or}
  \lnot (x \lor y)
  &\leadsto
  \lnot x \land \lnot y
  \\
  \tag{Distribute De Morgan - And}
  \lnot (x \land y)
  &\leadsto
  \lnot x \lor \lnot y
  \\
  \tag{Distribute $\land$ over $\lor$}
  x \land (y \lor z)
  &\leadsto
  (x \land y) \lor (x \land z)
\end{align}
\end{minipage}

\subsection{Or-wrapping}
\paragraph{Intuition} Restructuring quantifier predicates with top-level ORs for later rules.

\paragraph{Post-condition}
\begin{itemize}
  \item All terms with a set-like type (relations, bags, sets, sequences, etc.) must be in comprehension form.
  \item Quantifier predicates are in disjunctive normal form - top level or-clauses with inner and-clauses.
\end{itemize}

\noindent\begin{minipage}{\linewidth}
\begin{align}
  \tag{Or-wrapping \footnote{To simplify the matching process later on, we wrap every top-level AND statement (which is guaranteed to be a ListOp by the dataclass field type definition) with an OR.}}
  \bSetT{E}{\bigwedge P_i}
  &\leadsto
  \bSetT{E}{\bigvee \bigwedge P_i}
\end{align}
\end{minipage}

\subsection{Generator Selection}
\paragraph{Intuition} All nested ANDs are placed in a tree structure to better suit loop lowering.

\paragraph{Post-condition}
\begin{itemize}
  \item All terms with a set-like type (relations, bags, sets, sequences, etc.) must be in comprehension form.
  \item Each top-level or-clause within quantification predicates must have one selected `generator' predicate (GeneratorSelectionPredicate - GSP) of the form $x \in S$ that loops over its bound dummy variable $x$.
  \item All conjunctive clauses are wrapped in either a GSP or CombGSP structure.
  \item Quantifier predicates are in disjunctive normal form (with GSP replacing AND structures) - top level or-clauses with inner and-clauses.
\end{itemize}

\paragraph{Notes} All matches of this phase occur only inside quantifier predicates. GSP is a tuple of form (generator chain, predicates) that can be flattened to a conjunctive clause. A CombGSP is a triple of form (shared generator, disjunctive children predicates/generators, predicates) that can likewise be flattened into a conjunctive clause. We keep the structure of these tuples distinct to ease the rewriting process.

\paragraph{Brainstorming selection heuristics}
Conditions to consider:
\begin{itemize}
  \item Prefer composition chains in case of nested loops (ex. $x \mapsto y \in R \land y \mapsto z \in Q$, but what about renaming? - $x \mapsto y \in R \land y' \mapsto z \in Q \land y = y'$). Perhaps this could just be a preference for relations over sets if we see a nested quantifier.
  \item Choose most common generator among a list of or-clauses (allows for greater simplification later on)
  \item Choose smallest generator (by set size). This information may not always be accessible (ex. if a set is created by reading values from standard input). Functions may need to choose this on a case-by-case basis (ie. one function call could have two args, with a small set on the left arg and a large set on the right arg. But what if the sizes are reversed later in the code? We've already statically lowered it).
  \item When should constant folding happen? Equality substitution necessary for this?
  \item This may need to work with nesting considerations.
  \item What if we try moving these optimizations to $loop$ structures far later in the pipeline?
\end{itemize}

\noindent\begin{minipage}{\linewidth}
\begin{align}
  \tag{GSP Wrapping \footnote{GSP is a tuple-like structure, where all entries can be flattened into an AND. The LH term must occur inside a quantifier's predicate - one generator per top-level or-clause. Chained generators may be necessary to allow for nested loop operations (ie. non-top-level clauses may require generators). $P_g$ is a list of chained generators, specific set membership clauses (of form $x \in S$) distinguished from the rest of $\bigwedge P_i$. Currently, the selection of $P_g$ is arbitrary (and thus the rewrite system is not confluent), but heurestics may be added later to choose better generators.}}
  \bigwedge P_i
  &\leadsto
  GSP(\bigwedge P_{g_i}, \bigwedge_{P_i \notin P_g} P_i)
  \\
  \tag{Nested Generator Selection \footnote{$free$ is a function that returns true when variables in the predicate are defined (either bound by the current generator or bound prior to the current statement)}}
  GSP(x \land xs, P) \lor GSP(x \land ys, Q)
  &\leadsto
  CombGSP(x, GSP(xs, P) \lor GSP(ys, Q))
\end{align}
\end{minipage}



\subsection{GSP to Loop}

\paragraph{Intuition} Start lowering expressions into imperative-like loops.

\paragraph{Post-condition}
\begin{itemize}
  \item All quantifiers are transformed into $loop$ structures.
  \item $loop$ predicates are of the form $x \in S \land \bigwedge P_i$.
  \item All $loop$ predicates have an assigned generator of the form $x \in S$.
\end{itemize}

\noindent\begin{minipage}{\linewidth}
\begin{align}
  \tag{Quantifier Generation \footnote{$\oplus$ works for any quantifier (but not $\forall$ and $\exists$). The identity and accumulate functions are determined by the realized $\oplus$. For example, if $\oplus = \sum$, the identity is 0 and accumulate is addition.}}
  \oplus E \mid P
  &\leadsto
  \begin{minipage}[]{0.4\textwidth}
  \begin{algorithmic}
  \State $a := identity(\oplus)$
    \Loop\ $P:$ % should we use the \in operator here, or just plaintext in?
        \State $a := accumulate(a, E)$
    \EndLoop
  \end{algorithmic}
  \end{minipage}
\end{align}
\end{minipage}
% \noindent\begin{minipage}{\linewidth}
% \begin{align}
%   \tag{Nested Quantifier}
%   \begin{minipage}[]{0.5\textwidth}
%   \begin{algorithmic}
%     \State $a := accumulator(a, \oplus(E \mid P))$
%   \end{algorithmic}
%   \end{minipage}
%   &\leadsto
%   \begin{minipage}[]{0.4\textwidth}
%   \begin{algorithmic}
%     \Loop\ $P:$
%       \State $a := accumulator(a, E)$
%     \EndLoop
%   \end{algorithmic}
%   \end{minipage}
% \end{align}
% \end{minipage}
\noindent\begin{minipage}{\linewidth}
\begin{align}
  \tag{Top-level Or-Loop}
  \begin{minipage}[]{0.3\textwidth}
  \begin{algorithmic}
    \Loop\ $\bigvee P_i:$
      \State body
    \EndLoop
  \end{algorithmic}
  \end{minipage}
  &\leadsto
  \begin{minipage}[]{0.5\textwidth}
  \begin{algorithmic}
    \Loop\ $P_0$
      \State $body$
    \EndLoop
    \Loop\ $P_1 \land \lnot P_0$
      \State $body$
    \EndLoop
    \Loop\ $P_2 \land \lnot \bigvee_{i < 2} P_i$
      \State $body$
    \EndLoop
  \end{algorithmic}
  \end{minipage}
\end{align}
\end{minipage}
%
\noindent\begin{minipage}{\linewidth}
\begin{align}
  \tag{Chained GSP Loop \footnote{$free$ considers defined variables at this point in time.}}
  \begin{minipage}[]{0.4\textwidth}
  \begin{algorithmic}
    \Loop\ $GSP(g \land gs, P)$
      \State body
    \EndLoop
  \end{algorithmic}
  \end{minipage}
  &\leadsto
  \begin{minipage}[]{0.4\textwidth}
  \begin{algorithmic}
    \Loop\ $SingleGSP(g, free(P))$
      \Loop\ $GSP(gs, bound(P))$
        \State body
      \EndLoop
    \EndLoop
  \end{algorithmic}
  \end{minipage}
\end{align}
\end{minipage}
%
% \noindent\begin{minipage}{\linewidth}
% \begin{align}
%   \tag{Single GSP Loop}
%   \begin{minipage}[]{0.4\textwidth}
%   \begin{algorithmic}
%     \Loop\ $GSP(g, P)$
%       \State body
%     \EndLoop
%   \end{algorithmic}
%   \end{minipage}
%   &\leadsto
%   \begin{minipage}[]{0.4\textwidth}
%   \begin{algorithmic}
%     \Loop\ $SingleGSP(g, P)$
%       \State body
%     \EndLoop
%   \end{algorithmic}
%   \end{minipage}
% \end{align}
% \end{minipage}
%
\noindent\begin{minipage}{\linewidth}
\begin{align}
  \tag{Empty GSP Loop}
  \begin{minipage}[]{0.4\textwidth}
  \begin{algorithmic}
    \Loop\ $GSP([], P)$
      \State body
    \EndLoop
  \end{algorithmic}
  \end{minipage}
  &\leadsto
  \begin{minipage}[]{0.4\textwidth}
  \begin{algorithmic}
    \If{$P$}
      \State body
    \EndIf
  \end{algorithmic}
  \end{minipage}
\end{align}
\end{minipage}
%
\noindent\begin{minipage}{\linewidth}
\begin{align}
  \tag{Combined GSP Loop}
  \begin{minipage}[]{0.4\textwidth}
  \begin{algorithmic}
    \Loop\ $CombGSP(g, gs, P)$
      \State body
    \EndLoop
  \end{algorithmic}
  \end{minipage}
  &\leadsto
  \begin{minipage}[]{0.4\textwidth}
  \begin{algorithmic}
    \Loop\ $SingleGSP(g, P)$
      \Loop\ $gs_0$
        \State body
      \EndLoop
      \Loop\ $gs_1$
        \State body
      \EndLoop
      \State ...
    \EndLoop
  \end{algorithmic}
  \end{minipage}
\end{align}
\end{minipage}

% \noindent\begin{minipage}{\linewidth}
% \begin{align}
%   \tag{Disjunct conditional}
%   \begin{minipage}[]{0.33\textwidth}
%   \begin{algorithmic}
%     \Loop\ $\bigvee GSP_i(P_{g_i}, P_i)$
%       \State body
%     \EndLoop
%   \end{algorithmic}
%   \end{minipage}
%   &\leadsto
%   \begin{minipage}[]{0.5\textwidth}
%   \begin{algorithmic}
%     \Loop\ $GSP_0(P_{g_0}, P_0):$
%       \State body
%     \EndLoop
%     \Loop\ $GSP_1(P_{g_1}, P_1 \land \lnot GSP_0):$
%       \State body
%     \EndLoop
%     \Loop\ $GSP_2(P_{g_2}, P_2 \land \lnot (\bigvee_{i < 2} GSP_i)):$
%       \State body
%     \EndLoop
%     \State ...
%   \end{algorithmic}
%   \end{minipage}
%   \\
%   \tag{Disjunct Conditional 2}
%   \begin{minipage}[]{0.3\textwidth}
%   \begin{algorithmic}
%     \Loop\ $GSP(P_g, \bigvee P_i)$
%       \State body
%     \EndLoop
%   \end{algorithmic}
%   \end{minipage}
%   &\leadsto
%   \begin{minipage}[]{0.8\textwidth}
%   \begin{algorithmic}
%     \Loop\ $GSP(P_g, \bigwedge True):$
%       \If{$\bigvee_{ P_i \neq GSP(...)} P_i$}
%         \State body
%       \EndIf
%       \Loop\ $\bigvee_{P_i: GSP(P_{ig}, P_{is})} GSP(P_{g_i}, P_{is} \land \lnot \bigvee_{P_i \neq GSP(...)} P_i):$
%         \State body
%       \EndLoop
%     \EndLoop
%   \end{algorithmic}
%   \end{minipage}
% \end{align}
% \end{minipage}

\subsection{Relational Subtyping Loop Simplification}

\paragraph{Intuition} Simplify unnecessary iteration structures into direct accesses.

\paragraph{Post-condition}
\begin{itemize}
  \item All quantifiers are transformed into $loop$ structures.
  \item $loop$ predicates are of the form $x \in S \land \bigwedge P_i$.
  \item All $loop$ predicates have an assigned generator of the form $x \in S$.
\end{itemize}
No change from previous, but the number of loop structures should not increase.

\noindent\begin{minipage}{\linewidth}
\begin{align}
  \tag{Total membership elimination \footnote{$R$ is total and $x$ satisfies the type of $R$'s domain. Currently unused since it may eliminate some generators - move higher in the list?}}
  x \in dom(R)
  &\leadsto
  True
  \\
  \tag{Surjective membership elimination \footnote{$R$ is surjective and $x$ satisfies the type of $R$'s range. Currently unused since it may eliminate some generators - move higher in the list? Or }}
  x \in ran(R)
  &\leadsto
  True
\end{align}
\end{minipage}
\noindent\begin{minipage}{\linewidth}
\begin{align}
  \tag{Concrete Domain Image}
  \begin{minipage}[]{0.55\textwidth}
  \begin{algorithmic}
    \Loop\ $SingleGSP(x \mapsto y \in R, x = a \land P)$
      \State body
    \EndLoop
  \end{algorithmic}
  \end{minipage}
  &\leadsto
  \begin{minipage}[]{0.6\textwidth}
  \begin{algorithmic}
    \If{$a \in dom(R)$}
      \Loop\ $SingleGSP(y \in R[a], P[x := a])$
        \State body
      \EndLoop
    \EndIf
  \end{algorithmic}
  \end{minipage}
\end{align}
\end{minipage}
\noindent\begin{minipage}{\linewidth}
\begin{align}
  \tag{Concrete Range Image \footnote{Requires efficient lookups for $ran$, inverse, and image}}
  \begin{minipage}[]{0.55\textwidth}
  \begin{algorithmic}
    \Loop\ $SingleGSP(x \mapsto y \in R, y = a \land P)$
      \State body
    \EndLoop
  \end{algorithmic}
  \end{minipage}
  &\leadsto
  \begin{minipage}[]{0.6\textwidth}
  \begin{algorithmic}
    \If{$a \in ran(R)$}
      \Loop\ $SingleGSP(x \in R^{-1}[a], P[y := a])$
        \State body
      \EndLoop
    \EndIf
  \end{algorithmic}
  \end{minipage}
\end{align}
\end{minipage}
\noindent\begin{minipage}{\linewidth}
\begin{align}
  \tag{Single Element Loop}
  \begin{minipage}[]{0.5\textwidth}
  \begin{algorithmic}
    \Loop\ $SingleGSP(y \in R[x], P)$
      \State body
    \EndLoop
  \end{algorithmic}
  \text{where $free(x)$ and $R$ is many-to-one}
  \end{minipage}
  &\leadsto
  \begin{minipage}[]{0.5\textwidth}
  \begin{algorithmic}
    \If{$P[y:=R(a)]$}
      \State $body[y:=R(a)]$
    \EndIf
  \end{algorithmic}
  \end{minipage}
\end{align}
\end{minipage}
\noindent\begin{minipage}{\linewidth}
\begin{align}
  \tag{Singleton Membership Elimination}
  \begin{minipage}[]{0.5\textwidth}
  \begin{algorithmic}
    \Loop\ $SingleGSP(x \in \{y\}, P)$
      \State body
    \EndLoop
  \end{algorithmic}
  \end{minipage}
  &\leadsto
  \begin{minipage}[]{0.5\textwidth}
  \begin{algorithmic}
    \If{$P[x:=y]$}
      \State $body[x:=y]$
    \EndIf
  \end{algorithmic}
  \end{minipage}
\end{align}
\end{minipage}

\subsection{Loop Code Generation}

\paragraph{Intuition} Eliminate all intermediate loop structures.

\paragraph{Post-condition}
\begin{itemize}
  \item AST is in imperative code style (for loops, if statements, etc).
  \item All $loop$ and quantification constructs have been eliminated.
  \item Some variables may not be defined.
\end{itemize}

\noindent\begin{minipage}{\linewidth}
\begin{align}
  \tag{Conjunct Conditional \footnote{Function $free$ returns clauses in $P$ that contain only free + defined variables. $bound$ returns the clauses that contain the bound variable $x$ or undefined variables. $P_g$ is the selected generator.}}
  \begin{minipage}[]{0.4\textwidth}
  \begin{algorithmic}
    \Loop\ $SingleGSP(P_g, \bigwedge P_i)$
      \State body
    \EndLoop
  \end{algorithmic}
  \end{minipage}
  &\leadsto
  \begin{minipage}[]{0.5\textwidth}
  \begin{algorithmic}
    \If{$\bigwedge_{free(P_i)} P_i$}
      \For{$P_g$}
        % \State $P_as$ % TODO rewrite these to be more clear that they are assignments
        \If{$\bigwedge_{bound(P_i)} P_i$}
            \State body
          % \If{$Q_0$}
          %   \State body
          % \EndIf
          % \If{$Q_1 \land \lnot Q_0$}
          %   \State body
          % \EndIf
          % \If{$Q_2 \land \lnot (\bigvee_{i < 2} Q_i)$}
          %   \State body
          % \EndIf
          % \State ...
        \EndIf
      \EndFor
    \EndIf
  \end{algorithmic}
  \end{minipage}
\end{align}
\end{minipage}



\subsection{Replace and Simplify}

\paragraph{Intuition} Eliminate all undefined variables (with implicit $\exists$ quantifiers).

\paragraph{Post-condition}
\begin{itemize}
  \item AST is in imperative code style (for loops, if statements, etc).
  \item All variables are defined.
\end{itemize}

\noindent\begin{minipage}{\linewidth}
\begin{align}
  \tag{Equality Elimination \footnote{$x$ is an undefined, unbound variable in the current scope. $E$ is an expression that does not contain $x$. Simplify resulting booleans.}}
  \begin{minipage}[]{0.5\textwidth}
  \begin{algorithmic}
    \If{$Identifier(x) = E \land P$}
      \State body
    \EndIf
  \end{algorithmic}
  \end{minipage}
  &\leadsto
  \begin{minipage}[]{0.4\textwidth}
  \begin{algorithmic}
    \If{$P[x := E]$}
      \State body[x := E]
    \EndIf
  \end{algorithmic}
  \end{minipage}
\end{align}
\end{minipage}
%
\noindent\begin{minipage}{\linewidth}
\begin{align}
  \tag{Simplify And-true}
  P \land True
  &\leadsto
  P
  \\
  \tag{Simplify And-false}
  P \land False
  &\leadsto
  False
  \\
  \tag{Simplify Or-true}
  P \lor True
  &\leadsto
  True
  \\
  \tag{Simplify Or-false}
  P \lor False
  &\leadsto
  P
  \\
  \tag{Flatten Nested Statements}
  Statement(Statement(x))
  &\leadsto
  Statement(x)
\end{align}
\end{minipage}


% \section{Implementation Representation}
% Different implementations of each data type will have varying strengths and weaknesses, not only in theoretical asymptotic time and space, but in concrete real-world tests. Cache usage and additional information through object metadata may prove influential on smaller tests. Since this document is only concerned with the theoretical compiler specification, we analyze the theoretical time and space complexity, then pair gathered examples with a test plan for hardware considerations.

% A first approach to tackling these type representations would likely constitute a linked list. The space requirements for enumeration are straightforward, with extra allocations for link pointers. Insertions for unordered collections or append/concat operations are $O(1)$, but $O(n)$ for indexed insertion and union with one element. Lookups for all collections are $O(n)$, but this running time is undesirable for the often-used \texttt{in} operator for set-generated code. Since linked lists naturally enforce element order, this structure may be suitable for fast-changing sequences. Although, a limited-size sequence may be better suited for a contiguous array for $O(1)$ indexing. \textit{TODO: For sequences, we should also see if trees/heaps or bloom filters could provide efficient membership checking. Bloom filters are probabilistic but can determine $\neq$ operations.}

% On the other hand, hashmaps with $O(1)$ membership and element lookups are useful for all unordered collections. Relations may need bidirectional hashmaps that can efficiently handle many-to-many relations.

% Compressed bitmaps may be used for sets, but require a lot of space for sparse elements.

% Bags may be implemented either as a (linked) list, a set of tuples where the number of element occurrences is stored in the second tuple component, or a relation where the number of occurrences is the codomain.
\printbibliography

\end{document}