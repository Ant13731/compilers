% This is samplepaper.tex, a sample chapter demonstrating the
% LLNCS macro package for Springer Computer Science proceedings;
% Version 2.21 of 2022/01/12
%
\documentclass[runningheads]{llncs}

\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{amsmath, amsthm}
\usepackage{amssymb}
\usepackage{listings}
\usepackage[svgnames]{xcolor}
\usepackage{tikz}
\usepackage{array}
% If possible, figure files should be included in EPS format.
\usepackage{graphicx}
\usepackage[backend=biber, maxbibnames=9]{biblatex}
\usepackage[noend]{algpseudocode}
\usepackage{algorithm}
\usepackage{mathtools}
\usepackage{xcolor}
\usepackage{subcaption}
\usepackage{wrapfig}
\usepackage{color}
\usepackage{hhline}
\usepackage[utf8]{inputenc}
\usepackage{ stmaryrd }
\usepackage{hyperref}
\usepackage{bsymb}


% Display URLs in blue roman font according to Springer's eBook style:
\renewcommand\UrlFont{\color{blue}\rmfamily}
\urlstyle{rm}

% Set comprehension notation
\newcommand{\Set}[2]{%
  \{\, #1 \mid #2 \, \}%
}

% B-like Set comprehension notation
\newcommand{\bSet}[3]{%
  % \{\, #1 \cdot #2 \mid #3 \, \}%
  \{\, #1 \mid #2 \cdot #3 \, \}%
}
\newcommand{\bSetT}[2]{%
  \{\, #1 \mid #2 \,\}%
}
% List comprehension notation
% \newcommand{\List}[2]{%
%   [\, #1 \mid #2 \, ]%
% }
% % List concatenation
% \newcommand{\concat}{%
%   \mathbin{{+}\mspace{-8mu}{+}}%
% }

\allowdisplaybreaks
% \addtolength{\textfloatsep}{-0.5cm}

\addbibresource{submission.bib}

\begin{document}
%
\title{Generating Implementations of Data Type Operations}
% \title{Synthesis of Data Type Operations}
%
%\titlerunning{Abbreviated paper title}
% If the paper title is too long for the running head, you can set
% an abbreviated paper title here
%
\author{Anthony Hunt\inst{1}\orcidID{0009-0005-1085-3343} \and
Emil Sekerinski\inst{1}\orcidID{0000-0001-9788-5842}}
%
\authorrunning{A. Hunt and E. Sekerinski}
% First names are abbreviated in the running head.
% If there are more than two authors, 'et al.' is used.
%
\institute{Department of Computing and Software, McMaster University, Hamilton, ON L8S4L8, Canada
\email{\{hunta12,emil\}@mcmaster.ca}}
%
\maketitle              % typeset the header of the contribution
%
% \begin{abstract}
% The abstract should briefly summarize the contents of the paper in
% 150--250 words.
% \keywords{Abstract Data Types  \and Rewriting \and Compiler Optimization.}
% \end{abstract}
%
%
%

% Rough work
% To ensure consistency within this paper, we define the following:
% \begin{description}
% \item[Set] An unordered, unique collection of similar elements.
% \item[Sequence]An ordered collection of similar elements.
% \item[Relation]A set of tuples mapping elements from one domain to another domain.
% \end{description}
%
% Questions/topics
%
% Intro
% - significance of data structures in interpreting and manipulating data
% - modelling real-world phenomena using formal methods (mention event b)
%   - gently introduce modelling notation?
% Background/Motivation
% - Why should we use ADTs over classes/algebraic data types/functional structures
% - How are ADTs currently used (in what capacity, maybe some languages/examples)
% - How are ADT-alternatives currently used (general languages, formal method-based languages)?
%   - How can these be transformed into ADTs?
% - Once we justify ADTs, why optimize?
%   - Why use rewriting for optimization?
%   - Any current work on rewriting/optimization, maybe ADT specifics
% - Extensive work done on sequences (A theory of lists)
% - Current modelling languages/syntax - event b, alloy, Z, UML
% - Why focus on modelling languages? use examples - birthday book
% - Specware? TODO read first
% Methods
% - What ADTs do we support specifically? (table)
% \subsection{Emphasized Abstract Data Types}

% - Justify pointwise notation instead of point-free notation
% - Relation of ADTs to other languages (both old and modern, general purpose and modelling-based)
% - Present a rewrite system to convert high level syntax to optimized IR
% - Mention code generation, optimal concrete data structures (LLVM, hashmaps, roaring bitsets)
% - Show grammar if there is room? Some rewrite rules? A strategy for combining rewrite rules?
% Results
% - Examples of full optimization (what source code and generated LLVM looks like?)
% - Performance comparisons between languages (requires full compiler pipeline implementation?)
% -
% Conclusion
% - Review completed work, reiterate importance

\section{Introduction}

% \paragraph{What is the setting?}
% Problem models (e.g. in UML, Event-B, Alloy) and software specifications (e.g. in Dafny, Frama-C) involve the use of sets, relations, functions, sequences, and bags. Programming languages support some operations on those, while modelling and specification languages may support more operations but are not executable. In this work, we investigate how from programs using the operations of Tables 1, 2, and 3. highly efficient implementations can be synthesized.
% Modelling problems, as in UML, Event-B, and Alloy, and specifying software, as in Dafny and Frama-C, involves the use of abstract data types, notably sets, sequences, maps, relations, and bags.
%Software specification languages like UML, Event-B, Alloy, Dafny, and Frama-C often use abstract collection data types (ADTs) as a vehicle for modelling relationships between pieces of information. Sets, sequences, relations, and bags are all essential elements of a formal methods toolkit, with each type accompanied by an expressive set of operators and rich, universally agreed-upon semantics \cite{gries1993logical}. However, specifications are restrictive by nature, focused on proving correctness rather than providing an efficient runtime.
% Conversely, modern programming languages like Python, Go, Rust, JavaScript, and Haskell support some operations on some abstract data types, but tend to encourage the use of implementation-aware types like arrays and classes. In ongoing work, we analyze how a programming language can be extended with more operations on data types from which highly efficient implementations can be generated that guarantee bounds for runtime and memory consumption. In this short paper, we focus on the data types and operations of Table
System specifications in modelling languages (like UML, Event-B, and Alloy) and specification languages (such as Dafny and Frama-C) rely on abstract collection data types to describe properties and expected behaviour. Sets, sequences, relations, maps, and bags are all indispensable, each accompanied by an expressive set of operators. %and rich, universally agreed-upon semantics \cite{gries1993logical}.
Conversely, modern programming languages (like Python and Haskell) support only a subset of the those data types and operators, instead encouraging the use of implementation-aware types like arrays and classes.
% In ongoing work, we investigate how programming languages can be extended with more operations on data types from which efficient implementations with guaranteed bounds for runtime and memory consumption can be generated.
In ongoing work, we investigate how programming languages can be extended with more operations on data types. We seek to synthesize efficient implementations of data type operations with guaranteed bounds for runtime and memory consumption.
Our focus is on those of Table~\ref{tab:ADTOps}, which are a subset of Event-B data types~\cite{abrial2010modeling}. Relations are sets of pairs, and functions are functional relations.



% In ongoing work, we investigate efficient generation of data type operations with guaranteed bounds for runtime and memory consumption
% In ongoing work, we analyze how a programming language can be extended with more operations on data types from which highly efficient implementations can be generated that guarantee bounds for runtime and memory consumption. In this short paper, we focus on the data types and operations of Table
% Some discussion notes for this first paragraph (3 pages isnt a lot so I just want to make sure we optimize our meaning-per-word)
% - If you had to group the two sets of languages in the first sentence, what would be their categories? I think UML, Event-B, ... can be classified as modelling languages (not really intended for execution), but Dafny is a fully executable language and FramaC is more of a code analyzer? Dafny, FramaC, JML kind of like addons to existing languages (that use ADTs for prepost conditions)
% - The reason I changed the phrase "... involves the use of ..." in the original version of the first sentence is to:
%   - emphasize that ADTs are more than just a part of these languages - they are foundational to modelling and formal methods (ex. in Alloy, relations are the only collection type). The word "involves" might weaken our motivation.
%   - provide context clues for what we mean by "Abstract Data Type". Although the audience are experienced enough in CS to know this, I know in my first 4Z03 assignment I was a little confused between algebraic/abstract. Giving the word "collection" or "iterable" somewhere in the sentence might get the idea across better, without needing to mention "sets, sequences, ..."
% - One of the main motivations in your original proposal is the idea that these languages can be picked up quickly because everyone that knows of discrete math can read this kind of notation, and its pretty universal aside from syntactical differences. I think this is an important point that we can just slide in somewhere without much space loss.
% - "support some ... on some..." maybe could be "support only a subset of formal ADTs and ADT operators, instead encouraging the use..."
% - "In ongoing work..." -> "In ongoing work, we investigate optimization of efficient ADT operations with efficient, guaranteed bounds for runtime and memory consumption"
% - Remove the "in this short paper" sentence - is it fine to put it at the end of the introduction, or is it better in the first paragraph because the paper is only 3 pages?
%   - meant to restrict scope of paper, not a preview of the contents

% - using ADTs for modelling is not specific to languages but is a general principle
% - ADTs used for modelling -> these are the languages that use those ADTs ( langs support our claim)

\begin{table}[tb]
    \centering
    \caption{Selected operators on sets and relations.}
    \begin{tabular}{|c|c||c|c|}
    \hhline{|--||--|}
    % \multicolumn{2}{|c||}{Sets} & \multicolumn{2}{|c|}{Relations} \\
    % \hhline{:==::==:}
    Syntax & Label/Description & Syntax & Label/Description\\
    \hhline{|--||--|}
    $set(T)$ & Unordered, unique collection             & $S \pfun T$ & Partial function \\
    $S \leftrightarrow T$ & Relation, $set(S\times T)$  & $S \tinj T$& Total injection\\
    $\emptyset$ & Empty set                             & $x \mapsto y$ & Pair (relational element) \\
    $\{x,y,...\}$ & Set enumeration                     & $dom(S)$ & Domain\\
    $\bSet{x \in S}{P}{E}$ & Set comprehension          & $ran(S)$ & Range\\
    $S \cup T$ & Union                                  & $R[S]$ & Relational image\\
    $S \cap T$ & Intersection                           & $R \ovl Q$ & Relational overriding\\
    $S \setminus T$ & Difference                        & $R \circ Q$ & Relational composition\\
    $S \times T$ & Cartesian Product                    & $S \triangleleft R$ & Domain restriction\\
    $S \subseteq T$ & Subset                            & $R^{-1}$ & Relational inverse\\
    \hhline{|--||--|}
    % $f(S)$ & Function application\\ % is this like function mapping over a set? do we need to include this?
    \end{tabular}


    % \begin{tabular}{l@{~}l|l@{~}l}
    %     \hline
    %     $set(S)$ & finite set & $S \to T$ & partial function \\
    %     $S \leftrightarrow T$ & relation, $set(S \times T)$ & $S \to T$ & total function \\
    %     \hline
    %     $\{\}$ & empty set & $\{E, F\}$ & set enumeration \\
    %     $E \mapsto F$ & pair & $\{z \cdot P \mid E\}$& set comprehension \\ % For set constructor notation, I made a command \Set{<dummy var>}{<generators and conditions>} in case we want to quickly change the style in the future - it also saves on some typing
    %     $dom(R)$ &  domain & \\
    %     $ran(R)$ & range & \\
    %     $f(E)$ & function application & \\
    %     $R[S]$ & relational image & \\
    %     $R \override Q$ &relational overriding & \\
    %     $Q \circ R$ & relational composition & \\
    %     $R^{-1}$ &relational inverse & \\
    %     $S \triangleleft R$ &domain restriction & \\
        % Domain Restriction &  = \Set{x \mapsto y}{x \mapsto y \in R \land x \in S}$\\ %& $\triangleleft: set[T] \times relation[T,V] \rightarrow relation[T,V]$ &
        % Domain Subtraction & $S \domsub R = \Set{x \mapsto y}{x \mapsto y \in R \land x \notin S}$\\ %& $\domsub: set[T] \times relation[T,V] \rightarrow relation[T,V]$ &
        % Range Restriction & $R \triangleright S = \Set{x \mapsto y}{x \mapsto y \in R \land y \in S}$\\ %& $\triangleright: set[V] \times relation[T,V] \rightarrow relation[T,V]$ &
        % Range Subtraction & $R \ransub S = \Set{x \mapsto y}{x \mapsto y \in R \land y \notin S}$\\ %& $\ransub: set[V] \times relation[T,V] \rightarrow relation[T,V]$ &

        % \hline

        % Relation Enumeration & Literal collection of elements to create a relation.\\ %& $\{x \mapsto y, a \mapsto b,...\}: relation[T, V]$ &
        % Identity & $id(S)= \Set{x \mapsto x}{x \in S}$\\ %& $id: set[T] \rightarrow relation[T,T]$ &
        % Domain & $dom(R) = \Set{x}{x \mapsto y \in R}$\\ %& $dom: relation[T,V] \rightarrow set[T]$ &
        % Range & $ran(R) = \Set{y}{x \mapsto y \in R}$\\ %& $ran: relation[T,V] \rightarrow set[V]$ &
        % \hline
        % Relational Image & $R[S] = \Set{y}{x \in S \land x \mapsto y \in R}$ \\ %& $([]): relation[T,V] \times set[T] \rightarrow set[V]$ &
        % Overriding & $R \override Q = Q \cup (dom(Q) \domsub R)$\\ %\Set{x \mapsto y}{x\mapsto y \in Q \lor (x \mapsto y \in R \land x \notin dom(Q))}$ \\ %& $\override: relation[T,V] \times relation[T,V] \rightarrow relation[T,V]$ &
        % (Forward) Composition & $Q \circ R = \Set{x \mapsto z}{x \mapsto y \in R \land y \mapsto z \in Q}$\\ %& $\circ: relation[V,W] \times relation[T,V] \rightarrow relation[T,W]$ &
        % Inverse & $R^{-1} = \Set{y \mapsto x}{x \mapsto y \in R}$ \\ %& $(^{-1}): relation[T,V] \rightarrow relation[V,T]$ &
        % \hline
        % Domain Restriction & $S \triangleleft R = \Set{x \mapsto y}{x \mapsto y \in R \land x \in S}$\\ %& $\triangleleft: set[T] \times relation[T,V] \rightarrow relation[T,V]$ &
        % Domain Subtraction & $S \domsub R = \Set{x \mapsto y}{x \mapsto y \in R \land x \notin S}$\\ %& $\domsub: set[T] \times relation[T,V] \rightarrow relation[T,V]$ &
        % Range Restriction & $R \triangleright S = \Set{x \mapsto y}{x \mapsto y \in R \land y \in S}$\\ %& $\triangleright: set[V] \times relation[T,V] \rightarrow relation[T,V]$ &
        % Range Subtraction & $R \ransub S = \Set{x \mapsto y}{x \mapsto y \in R \land y \notin S}$\\ %& $\ransub: set[V] \times relation[T,V] \rightarrow relation[T,V]$ &
        % % \hline % Do we need to include tests for total, surjective, injective, etc.?
        % % Eventually add closures
        % \hline
    % \end{tabular}
    \label{tab:ADTOps}
\end{table}
% Discussion for table
% I assume this table will replace the other 3 tables, since we dont have much space to work with.
% - Is this table solely for relations?
% - Maybe we could draw it out on paper first to see how it looks?

% \paragraph{What is the related work?}
%Previous work \cite{gries1993logical, abrial2010modeling, robinson2014concise, jackson2019alloy} on the theory and implementation of ADTs has independently focused on either boolean algebra, number theory, sets, sequences, and relations. In particular, development of sequences/lists has been essential to the feasibility of modern functional languages (like Haskell) \cite{broy1987introduction, brown2011architecture, peytonjones2001playing}. % TODO needs more motivation? not sure what to write

% Example comparison of our operators against other languages (tried to keep it short but concrete)
% Our sparse definition of select operators affords some flexibility compared to imitations of these types in general purpose languages, yet is sufficient to serve as a drop-in implementation of specification languages. For example, the standard Python dictionary mimics a relation, but does not allow modelling of many-to-one or many-to-many relationships. Further, since Python objects are mutable by default and the keys of a dictionary must be hashable, it can be a hassle to use complex modelling structures as the domain of a relation. On the other hand, every object in a specification language like Alloy is a relation, with expressive capabilities similar to a full-fledged relational databases. By focusing on efficient implementations of relations, we can then accommodate the execution of more general relation specifications.

% We assume well-studied and standardized \cite{gries1993logical} algebraic notation for booleans and numbers to create definitions for the common collection types: sets, sequences, and relations. Then, we define expressive operators on sets, sequences, and relations by way of Table~\ref{tab:setOps}, Table~\ref{tab:seqOps}, and Table~\ref{tab:relOps} respectively.
% Discussion for related work
% - Too many/irrelevant citations?

% Thesis leading sentence not really needed
% The rest of this paper will demonstrate the semantic capabilities of ADTs for real-world models and then discuss a rewrite system to efficiently compile ADT operators with a reliable, efficient runtime.

% \section{Some Examples}

% \subsection{The Birthday Book}
% % birthday book
% The birthday book problem, as mentioned in Spivey's introduction to formal Z notation \cite{spivey1989birthday}, is as follows: A birthday book tracks the relationship between the names of people and their birthdays. All names are assumed to be unique, yet two or more people may share the same birthday. Using this book, we attempt to answer two main questions:
% \begin{itemize}
%     \item When is the birthday of a particular person?
%     \item Who has a birthday on a given date?
% \end{itemize}
% A straightforward model for this situation is a mapping from people to birthdays. For the sake of notation, we name this relation $birthdays$. Then, the first question is answered with a relational lookup $birthdays[\{name\}]$ and the second with its inverse: $bithdays^{-1}[\{date\}]$.

% Extending the problem, we demonstrate the ergonomics of set operators over real world models. With consideration for the bidirectional mapping setup from the previous questions, we seek to efficiently implement the following scenarios:
% \begin{itemize}
%     \item Two disjoint groups of friends, each with an originally independent birthday book, become acquainted and wish to merge their records together, removing duplicate entries for mutual friends.
%     \item A subset of the original friend group eventually have a falling out and wishes to separate from the main group. This problem then requires one birthday book to be separated into two.
%     \item Finally, when planning for a birthday party, the group wants to celebrate not only a person's birthday, but any and all national holidays associated with that day.
% \end{itemize}
% Using relational operators, the first question can be modelled with a simple union: $birthdays = birthdays \cup newBirthdays$ and the second with domain subtraction: $namesToRemove \domsub birthdays$. The third solution requires the inverse operator, relational composition, and a new relation $holidays$ from holiday names to dates: $birthday \circ holidays^{-1}[\{name\}]$.

\section{Motivating Example: A Visitor Information System}
% visitor information system
Consider a service system that tracks all attendees and workshops within a conference. One visitor may attend at most one workshop per day. Only one workshop may be held in a room throughout the day. An appropriate model is:
\begin{align}
    location: Workshop \tinj Room \\
    attends: Visitor \pfun Workshop
\end{align}
% TODO Do we need this sentence?
% Visitor $vis$ cancelling the registration is expressed by $attends := attends \domsub {vis}$.
If a workshop organizer needs to order meals for each attendee in $room$, their number is given by:
\begin{align}
card((location^{-1} \circ attends^{-1})[\{room\}])
\end{align}
%The main question is as follows: how many meals would the workshop coordinators need to prepare, if they wished to serve a meal for all attendees within a specific room?

%With relations and relational operators, the answer is concise. Let $location$ and $attends$ be defined as follows:
% be a relation between presentations and their assigned room, and let $attends$ be a relation between visitors and presentations.
%Then, the result of the above query is the cardinality $card()$ of $$.
We envisage that programmers write such expressions, and efficient code is generated. A naive implementation constructs intermediate relations for $location^{-1}$ and $attends^{-1}$. We show how this can be avoided. The implementation in Fig.~\ref{fig:visitorImpl}~(a) assumes that both functions are implemented as sequences, $location: seq(Workshop \times Room)$ and $attends: seq(Visitor \times Workshop)$. The implementation in Fig.~\ref{fig:visitorImpl}~(b) assumes that $location$ is a hashmap. Both implementations need only constant memory.
%Optimal code to solve this problem may vary depending on the underlying implementation, as shown in Figure~\ref{fig:visitorImpl}.
%
\begin{figure}[H] % Putting Here reduces the space between this figure and the next section
    \centering
    \begin{subfigure}[]{.47 \textwidth}
        \centering
        \begin{algorithmic}
            \State $card := 0$
            \For{$p,r$ {\bf in} $location$}
                \If{$r = room$}
                    \For{$v,p'$ {\bf in} $attends$}
                        \If{$p = p'$}
                            \State $card := card + 1$
                        \EndIf
                    \EndFor
                \EndIf
            \EndFor
        \end{algorithmic}
        \caption{The running time is proportional to $len(location) \times len(attends)$}
    \end{subfigure}
    \hfill
    \begin{subfigure}[]{.48 \textwidth}
        \centering
        \begin{algorithmic}
            \State $card := 0$
            \For{$v,p$ {\bf in} $attends$}
                \If{$location[{p}] = room$}
                    \State $card := card + 1$
                \EndIf
            \EndFor
        \end{algorithmic}
    \caption{Assuming $location$ is a hashmap with constant time lookup $location[p]$, the running time is proportional to $len(attends)$.}
    % \caption{Assuming the hashmap implementation of $location$ has constant time lookup for $location[p]$, the running time is proportional to $len(attends)$.}
    \end{subfigure}
    \caption{Two implementations of query (3).}
    \label{fig:visitorImpl}
\end{figure}

% Discussion
% - I originally thought this section should be short - just introduce the problem as concisely as possible, then move on to the rewrite section. Should we walk through the entire rewriting process here?
% - Should we even include the birthday book example? Maybe its just better to go in depth on the visitor information system since it is quicker to explain
%   - Do we discuss the underlying implementation too? (seq of pairs vs hashmap vs bihashmap)
%   - Do we discuss how function attributes like partiality/many to many/etc might change code generation? If so, we would need to state how we would keep track of this info (either user provided or check for properties at insertion)

% var location: Presentation >-> Room     -- injective total function
% var presents: Visitor -/-> Presentation -- partial function

% card((location^-1 o presents^-1)[{room}])

% Suppose that functions and relations are implemented as sequences of pairs:
% % put hashmap vs seq side-by-side. even default hashmaps are good

% var location: seq(Presentation x Room)
% var presents: seq(Visitor x Presentation)

% c := 0
% for p, r in location do
%     if r = room then
%         for v, q in presents do
%             if p = q then c := c + 1 ; break
% return c

\section{Term Rewriting Rules}

%Term rewriting systems are well known for their innate simplicity and decomposition of translation programs into atomic, provable components \cite{elco1998building, baader1998term, brown2011architecture}. In the setting of the visitor information system, we can lower the ADT-notated query into a guaranteed memory-efficient intermediate representation with only a few rewrite rules, shown below. For brevity, we only explore implementations of relations as a set of pairs, although the ideas presented can easily be extended to other ADTs and implementation data structures as necessary.

% General process/strategy for term rewriting
% - break everything down into set constructor notation
%   - card -> \sum should be the first thing to break down (outside operators first)
% - once in set notation, there should be a chain of compositions e_1 R_1 e_2 \land e_2 R_2 e_3 \land ...
% - choose one of those chains to be the starting generator, preferably one with a property attached - this property preference is just to exist loops as soon as possible, easy to determine the most iteration-saving property for 2-length compositions, but n-length may be trickier
% - continue down the chain doing for loops, eventually reaching the final part of the chain
% - then apply the dummy variable func in the innermost if statement - custom "folding" techniques for sum, product, etc. but should be able to accomodate any fold
The code generation is implemented by a term rewriting system. We give sufficiently many rewrite rules for transforming (3) into:
\begin{align}
% \sum p \mapsto r \in location \land v \mapsto p \in attends \land r = room \mid 1
\sum p \mapsto r \in location \land v \mapsto p' \in attends \mid p = p' \land r = room \cdot 1
\end{align}
The basic strategy for set and relational expressions is to first normalize the expression as a set comprehension and then simplify conjuncts of the set comprehension body.
% A basic strategy for set and relational expressions is:
% \begin{enumerate}
%     \item Normalize the expression as a set comprehension.
%     \item Simplify and order conjuncts of the set comprehension body.
% \end{enumerate}
Necessary rewrite rules are:
\begin{align}
    \tag{Singleton membership}
    x \in \{E\} &\leadsto x = E\\
    \tag{Membership collapse} % also works for folds! maybe
    % {x \in \bSet{y}{E}{P}} &\rightarrow x \in E \mid P\\
    %
    % {x \in \bSet{y}{y \in E}{P}} &\rightarrow y \in E \mid P\\
    % {x \in \bSet{y \in S}{P}{E}} &\leadsto y \in S \mid P \cdot E\\
    x \in \bSet{y \in S}{P}{E(y)} \cdot F(x) &\leadsto y \in S \mid P \cdot F(E(y))\\
    %
    % \tag{Membership collapse} % also works for folds! maybe
    % \oplus x \mid {x \in \Set{y}{E}} &\rightarrow {} \oplus x \mid x \in E\\
    % \tag{Membership collapse (sets)}
    % \Set{x}{x \in \Set{y}{E}} &\rightarrow \Set{x}{E}\\
    \tag{Cardinality}
    card(S) &\leadsto \sum x \in S \cdot 1\\
    \tag{Image}
    % R[S] &\rightarrow \bSet{b}{a \mapsto b \in R}{a \in S}\\
    R[S] &\leadsto \bSet{x \mapsto y \in R}{x \in S}{y}\\
    \tag{Inverse}
    x \mapsto y \in R^{-1} &\leadsto y \mapsto x \in R\\
    % \bSet{f(a,b)}{a \mapsto b \in R^{-1}}{p(a,b)} &\rightarrow \bSet{f(b,a)}{b \mapsto a \in R}{p(a,b)}\\
    \tag{Composition}
    x \mapsto y \in (Q \circ R) &\leadsto x \mapsto z \in Q \land z' \mapsto y \in R \land z=z'
    % \bSet{f(a,b)}{a \mapsto b \in (Q \circ R)}{p(a,b)} &\rightarrow \bSet{f(a,b)}{a \mapsto c \in Q \land c \mapsto b \in R}{p(a,b)}
\end{align}
Once the entire expression is transformed into a set or relational comprehension, repeated application of rules below generates the algorithm in Fig.~\ref{fig:visitorImpl}~(a).
\begin{align}
    \tag{Summation}
    \sum x \in S \mid P \cdot E
    % \begin{aligned}
    % \sum &f(e_1, ..., e_{n+1}) \cdot \\ &e_1 \mapsto e_2 \in R_1 \land ... \land e_n \mapsto e_{n+1} \in R_n \\ & \mid P(e_1, ..., e_{n+1})
    % \end{aligned}
    &\leadsto
    % \fbox{%
    \begin{minipage}[]{0.4\textwidth}
    \begin{algorithmic}
    \State $c := 0$
    \For{$x \in S$}
        \If{$P$} % should we use the \in operator here, or just plaintext in?
            $c := c + E$
        \EndIf
    \EndFor
    % \State $c := 0$
    % \For{$e_1 \mapsto e_2$ in $R_1$}
    %     \If{$e_2 \mapsto e_3 \in  R_2$ and ... and $P$} % should we use the \in operator here, or just plaintext in?
    %         \State $c := c + f(e_1, ..., e_{n+1})$
    %     \EndIf
    % \EndFor
    % c := 0
    % for (e_1, e_2) in R_1:
    %     if p(e_1) and e_2 R_2 e_3 and ...
    %         f(e_1, ..., e_\{n+1\})
    \end{algorithmic}
    \end{minipage}
    % }
    \\
    \tag{Composed conditional}
    % \fbox{%
    \begin{minipage}[]{0.33\textwidth}
    \begin{algorithmic}
        % \If{$P$ and $e_1 \mapsto e_2 \in R_1$ and $Q$}\EndIf
        \If{$P \land x \in S \land Q$}
            $p$
        \EndIf
    \end{algorithmic}
    where $x$ not free in $P$ % primitive means the expression does not need a loop, or is already made of a function of only loop-bound variables
    % ie, we want to leave bound variables as high up as we can in the loop. Theres probably a nicer way to right this where we nest all loops than bubble up properties until we hit their topmost bound loop. For example:
    % for a in A:
    %   for b in B:
    %       for c in C:
    %           if p(a) and p(a,b) and p(b) and p(c)
    % ->
    % for a in A:
    %   if p(a):
    %       for b in B:
    %           if p(b) and p(a,b)
    %               for c in C:
    %                   if p(c)
    \end{minipage}
    % }
    & \leadsto
    % \fbox{%
    \begin{minipage}[]{0.26\textwidth}
    \begin{algorithmic}
    % \If{$P$}
    %     \For{$e_2 \mapsto e_3$ in $R_2$}
    %         \If{$Q$} \EndIf
    %     \EndFor
    % \EndIf
    \If{$P$}
        \For{$x \in S$}
            \If{$Q$}
                $p$
            \EndIf
        \EndFor
    \EndIf
    \end{algorithmic}
    \end{minipage}
    % }
\end{align}


% Rules:
% card(S) -> len(S)
% maybe add conditions for one-to-one, one-to-many (but use injective, surjective, etc. rules - say it is good modelling habit to put it in there
% possible optimization in the future (for now just use declared type), dynamically detect injectivity/etc of a function (by keeping track of it at insertion time)

% card(R[S]) ->
%     c := 0
%     for x, y in R do
%         if x in S then c := c + 1
%     return c

% E in {F} -> E = F

% (Q o R)[S] -> R[Q[S]]

% if E in S then p ->
%     for x in S do
%         if E = x then p ; break

% if E in R[S] then p ->
%     for x, y in R do
%         if x in S and
% Here:
% card((location^-1 o presents^-1)[{room}]) ->
%     card(presents^-1[location^-1[{room}]])
%     ->
%     c := 0
%     for x, y in presents^-1 do
%         if x in location^-1[{room}] then c := c + 1
%     return c
%     ->
%     c := 0
%     for y, x in presents do
%         if x in location^-1[{room}] then c := c + 1
%     return c
%     ->
%     c := 0
%     for y, x in presents do
%         if x in location^-1[{room}] then c := c + 1
%     return c

% no intermediate memory - proportional to output
% runtime is product of size of relations (maybe sum for union, etc)
% table of rewrite rules, maybe running time/space requirement for code generating rules
% for seq impl then its O(n^2), if its hash table, O(n) at most?

% Given the conciseness of examples in Section 2 and the long history of the field of formal methods, the expressive capabilities of ADTs are self-evident. But to justify the use of ADTs in real-world modelling software, they must be efficient in space, and where possible, runtime. For example, in an unoptimized language, the expression $(location^{-1} \circ attends^{-1})[\{room\}]$ from Section 2.2 would likely evaluate first the inverse of each relation, then build a new relation containing the composition of both inverses, and finally evaluate the relational image on the temporary relation. However, for large modelling objects, the process of copying is wasteful and unnecessary. A better system would combine the relations at iteration time, acting like a function composition of a lazily evaluated language (without the runtime overhead).

% Although set constructor notation has been somewhat discounted in recent work in favour of point-free notation, % TODO SOURCE - ASK
% the boolean representation of these relations reveals some missed optimizations. First, we can rewrite the expression $(location^{-1} \circ attends^{-1})[\{room\}]$ as $(attends \circ location)^{-1}[\{room\}]$. Then, we write the following set construction:
% \[
% \Set{v}{p \mapsto r \in location \land v \mapsto p \in attends \land r = room}
% \]
% One possible implementation of this comprehension is seen in Algorithm~\ref{algo:visitorMeals} make use of the fact that possible rooms are restricted by the lookup operator
% \begin{algorithm}
%   \caption{Implementation of $lookup$ with inverse composition}
%   \begin{algorithmic}
%     % \Inputs $room$
%     \Require $location \text{ is one-to-one or many-to-one}$
%     \State $ret \gets \emptyset$
%     \For{$v,m \in attends$}
%         \If{$location[m] = room$}
%             $ret \gets ret \cup \{v\}$
%         \EndIf
%     \EndFor
%   \end{algorithmic}
%   \label{algo:visitorMeals}
% \end{algorithm}


%\paragraph{How is the efficiency measured?}
% Discussion
% - Should this go in the term rewriting section? Write the efficiency beside each resulting algorithm?
% - Or is this more like "we have a test suite on several of these examples written in several languages"?

\section{Discussion}

% Term rewrite rules have historically been used for code generation. For example, \cite{elco1998building} devises a tactic language for applying rules and~\cite{peytonjones2001playing} allows programmers to specify rewrite rules for the GHC compiler. In this work, the programmer only specifies the data type implementation; the built in rewrite rules are specifically designed to guarantee runtime and memory consumption. Rewrite rules can also be used for source-to-source transformation like refactoring or transpiling. These have to be specified explicitly, and the result is again human-readable. Here, we apply the rules automatically, without the need for the result to be comprehensible. Specware allows algorithmic and data refinement transformations to be applied to specifications; the user has to make the design decisions. Our goal is more modest, as we only consider operations on data types, but intend to apply the transformations automatically. Relational databases provide query optimizations for the relational data model; here, we support modelling data types with arbitrary combinations of operations on those. The goal of this project is to bring programming languages closer to modelling languages.

% Should some of this be in the introduction looking at previous work? Ex. relational database info would go well with paragraph 2
Term rewriting has been used for optimization and code generation: \cite{elco1998building} devises a tactic language for applying rules, and~\cite{peytonjones2001playing} allows programmers to specify rewrite rules for GHC. In our work, programmers need only specify the data type implementation; a fixed set of rewrite rules guarantees predictable run times and memory consumption.
Rewrite rules have also been used for source-to-source transformation, like refactoring and transpiling. The rules aim to generate human-readable code. Here, the rules aim at efficiency without the need for the result to be comprehensible.

In Specware, algorithmic and data refinement transformations can be applied to axiomatic specifications; in~\cite{SmithWestfold20GeneratingTypeRefinements}, this is extended to inductively and co-inductively specified data types. Here, the data types are fixed, and we only consider automatically generating implementations of complex expressions. Relational databases provide query optimizations for the relational data model. Here, we support a wider range of modelling data types with an arbitrary combination of operations. The goal of this project is to bring programming languages closer to modelling languages while remaining competitive at runtime.

%\paragraph{What are the next steps?}

%\paragraph{What is the long-term goal of this project?}
% Discussion, one paragraph stating where we are, looking at supporting different implementations, dont mention dynamic injective function optimization, static stuff for now
% - Will we be making a fully fledged language out of these ideas? Would definitely have more control over the compilation pipeline.
% - Next steps/long term goal could be part of the same paragraph? start specific for next steps and generalize

% \begin{table}[]
% % \makebox[1 \textwidth][c]{       %centering table
% % {\resizebox{1 \textwidth}{!}{   %resize table
%     \centering
%     \caption{Collection of operators on set data types.}
%     \begin{tabular}{|c|c|}
%         \hline
%         Name & Definition \\ %& Type &
%         \hline
%         Empty Set & Creates a set with no elements.\\ %& $\emptyset: set[]$ &
%         Set Enumeration & Literal collection of elements to create a set.\\ %& $\{x, y, ...\}: set[T]$ &
%         Set Membership & The term $x \in S$ is True if $x$ can be found somewhere in $S$. \\ %& $\in: T \times set[T] \rightarrow bool$ &
%         \hline
%         Union & $S \cup T = \Set{x}{x \in S \lor x \in T}$ \\ %& $\cup: set[T] \times set[T] \rightarrow set[T]$ &
%         Intersection & $S \cap T = \Set{x}{x \in S \land x \in T}$ \\ %& $\cap: set[T] \times set[T] \rightarrow set[T]$ &
%         Difference & $S \setminus T = \Set{x}{x \in S \land x \notin T}$ \\ %& $\setminus: set[T] \times set[T] \rightarrow set[T]$ &
%         Cartesian Product & $S \times T = \Set{x \mapsto y}{x \in S \land y \in T}$ \\ %& $\times: set[T] \times set[V] \rightarrow relation[T,V]$ &
%         \hline
%         Powerset & $\mathbb{P}(S) = \Set{s}{s \subseteq S }$ \\ %& $\mathbb{P}: set[T] \rightarrow set[set[T]]$&
%         Magnitude & $\#S = \sum_{x \in S} 1$\\ %& $\#:set[T] \rightarrow int$ &
%         Subset & $S \subseteq T \equiv \forall x \in S: s \in T$ \\ %& $\subseteq: set[T] \times set[T] \rightarrow bool$ &
%         Strict Subset & $S \subset T \equiv S \subseteq T \land S \neq T$ \\ %& $\subset: set[T] \times set[T] \rightarrow bool$ &
%         Superset & $S \supseteq T \equiv \forall x \in T: s \in S$ \\ %& $\supseteq: set[T] \times set[T] \rightarrow bool$ &
%         Strict Superset & $S \supset T \equiv S \supseteq T \land S \neq T$ \\ %& $\supset: set[T] \times set[T] \rightarrow bool$ &
%         \hline
%         Set Mapping & $f * S = \Set{f(x)}{x \in S}$\\ %& $*: (T \rightarrow T') \times set[T] \rightarrow set[T']$ &
%         Set Filter & $p \triangleleft S = \Set{x}{x \in S \land p(x)}$\\ %& $\triangleleft: (T \rightarrow bool) \times set[T] \rightarrow set[T]$ &
%         % Reduction & $f / S = $ %& $/:(T\times T \rightarrow T) \times set[T] \rightarrow T$ &
%         \hline
%     \end{tabular}
%     \label{tab:setOps}
% % }}
% \end{table}
% \begin{table}[]
%     \centering
%     \caption{Collection of operators on sequence data types.}
%     \begin{tabular}{|c|c|}
%         \hline
%         Name & Definition \\ %& Type &
%         \hline
%         Empty List & Creates a list with no elements.\\ %& $[]: list[]$ &
%         List Enumeration & Literal collection of elements to create a list.\\ %& $[x, y, ...]: list[T]$ &
%         Construction & Alternative form of List Enumeration.\\ %& $(:):T \times list[T] \rightarrow list[T]$ &
%         List Membership & The term $x \texttt{ in } S$ is True if $x$ can be found somewhere in $S$. \\ %& $\texttt{in}: T \times list[T] \rightarrow bool$ &
%         \hline
%         Append & $[s_1, s_2, ..., s_n] + t = [s_1, s_2, ..., s_n, t]$ \\ %& $+: list[T] \times T \rightarrow list[T]$ &
%         Concatenate & $[s_1, ..., s_n] \concat [t_1, ..., t_n] = [s_1, ..., s_n, s_1, ... s_n]$ \\ %& $\concat: list[T] \times list[T] \rightarrow list[T]$ &
%         Length & $\#S = \sum_{x \texttt{ in } S} 1$ \\ %& $\#: list[T] \rightarrow int$ &
%         \hline
%         List Mapping & $f * S = \List{f(x)}{x \texttt{ in } S}$\\ %& $*: (T \rightarrow T') \times list[T] \rightarrow list[T']$ &
%         List Filter & $p \triangleleft S = \List{f(x)}{x \texttt{ in } S \land p(x)}$\\ %& $\triangleleft: (T \rightarrow bool) \times list[T] \rightarrow list[T]$ &
%         Associative Reduction & $\oplus / [s_1, s_2, ..., s_n] = s_1 \oplus s_2 \oplus ... \oplus s_n$\\ %& $/:(T\times T \rightarrow T) \times list[T] \rightarrow T$ &
%         Right Fold & $\texttt{foldr}(f, e, [s_1, s_2, ..., s_n]) = f(s_1 ,f(s_2 , f(..., f(s_n, e))))$\\ %& $\texttt{foldr}:(T\times V \rightarrow V) \times V \times list[T] \rightarrow V$ &
%         Left Fold & $\texttt{foldl}(f, e, [s_1, s_2, ..., s_n]) = f(f(f(f(e, s_1), s_2), ...), s_n)$\\ %& $\texttt{foldl}:(T\times T \rightarrow T) \times list[T] \rightarrow T$ &
%         \hline
%     \end{tabular}
%     \label{tab:seqOps}
% \end{table}
% \begin{table}[]
%     \centering
%     \caption{Collection of operators on relation data types.}
%     \begin{tabular}{|c|c|}
%         \hline
%         Name & Definition \\ %& Type &
%         \hline
%         Empty Relation & Creates a relation with no elements.\\ %& $\{\}:relation[]$ &
%         Relation Enumeration & Literal collection of elements to create a relation.\\ %& $\{x \mapsto y, a \mapsto b,...\}: relation[T, V]$ &
%         Identity & $id(S)= \Set{x \mapsto x}{x \in S}$\\ %& $id: set[T] \rightarrow relation[T,T]$ &
%         Domain & $dom(R) = \Set{x}{x \mapsto y \in R}$\\ %& $dom: relation[T,V] \rightarrow set[T]$ &
%         Range & $ran(R) = \Set{y}{x \mapsto y \in R}$\\ %& $ran: relation[T,V] \rightarrow set[V]$ &
%         \hline
%         Relational Image & $R[S] = \Set{y}{x \in S \land x \mapsto y \in R}$ \\ %& $([]): relation[T,V] \times set[T] \rightarrow set[V]$ &
%         Overriding & $R \override Q = Q \cup (dom(Q) \domsub R)$\\ %\Set{x \mapsto y}{x\mapsto y \in Q \lor (x \mapsto y \in R \land x \notin dom(Q))}$ \\ %& $\override: relation[T,V] \times relation[T,V] \rightarrow relation[T,V]$ &
%         (Forward) Composition & $Q \circ R = \Set{x \mapsto z}{x \mapsto y \in R \land y \mapsto z \in Q}$\\ %& $\circ: relation[V,W] \times relation[T,V] \rightarrow relation[T,W]$ &
%         Inverse & $R^{-1} = \Set{y \mapsto x}{x \mapsto y \in R}$ \\ %& $(^{-1}): relation[T,V] \rightarrow relation[V,T]$ &
%         \hline
%         Domain Restriction & $S \triangleleft R = \Set{x \mapsto y}{x \mapsto y \in R \land x \in S}$\\ %& $\triangleleft: set[T] \times relation[T,V] \rightarrow relation[T,V]$ &
%         Domain Subtraction & $S \domsub R = \Set{x \mapsto y}{x \mapsto y \in R \land x \notin S}$\\ %& $\domsub: set[T] \times relation[T,V] \rightarrow relation[T,V]$ &
%         Range Restriction & $R \triangleright S = \Set{x \mapsto y}{x \mapsto y \in R \land y \in S}$\\ %& $\triangleright: set[V] \times relation[T,V] \rightarrow relation[T,V]$ &
%         Range Subtraction & $R \ransub S = \Set{x \mapsto y}{x \mapsto y \in R \land y \notin S}$\\ %& $\ransub: set[V] \times relation[T,V] \rightarrow relation[T,V]$ &
%         % \hline % Do we need to include tests for total, surjective, injective, etc.?
%         % Eventually add closures
%         \hline
%     \end{tabular}
%     \label{tab:relOps}
% \end{table}





\begin{credits}
\subsubsection{\ackname} We acknowledge the support of the Natural Sciences and Engineering Research Council of Canada (NSERC), [grant RGPIN-2024-06779].
\end{credits}

%
% ---- Bibliography ----
%
% BibTeX users should specify bibliography style 'splncs04'.
% References will then be sorted and formatted in the correct style.
%
% \bibliographystyle{splncs04}
% \bibliography{mybibliography}
%
\printbibliography
% \begin{thebibliography}{8}
% \bibitem{ref_article1}
% Author, F.: Article title. Journal \textbf{2}(5), 99--110 (2016)

% \bibitem{ref_lncs1}
% Author, F., Author, S.: Title of a proceedings paper. In: Editor,
% F., Editor, S. (eds.) CONFERENCE 2016, LNCS, vol. 9999, pp. 1--13.
% Springer, Heidelberg (2016). \doi{10.10007/1234567890}

% \bibitem{ref_book1}
% Author, F., Author, S., Author, T.: Book title. 2nd edn. Publisher,
% Location (1999)

% \bibitem{ref_proc1}
% Author, A.-B.: Contribution title. In: 9th International Proceedings
% on Proceedings, pp. 1--2. Publisher, Location (2010)

% \bibitem{ref_url1}
% LNCS Homepage, \url{http://www.springer.com/lncs}, last accessed 2023/10/25
% \end{thebibliography}

% \section{Appendix}
% Derivation of $card((location^{-1} \circ attends^{-1})[\{room\}])$:
% \begin{align*}
% &card((location^{-1} \circ attends^{-1})[\{room\}])\\
% \leadsto & \langle \text{Cardinality } [S := (location^{-1} \circ attends^{-1})[\{room\}]] \rangle\\
% & \sum x \in (location^{-1} \circ attends^{-1})[\{room\}] \mid 1\\
% \leadsto & \langle \text{Image } [R,S := location^{-1} \circ attends^{-1}, \{room\}]\rangle\\
% & \sum x \in \{a \mapsto b \in location^{-1} \circ attends^{-1} \mid a \in \{room\} \cdot b\} \mid 1\\
% \leadsto & \langle \text{Singleton membership } [x, e := a, room] \rangle\\
% & \sum x \in \{a \mapsto b \in location^{-1} \circ attends^{-1} \cdot a = room \cdot b\} \mid 1\\
% % NOTE: "eliminating" b in this fashion really only works because the parent enumeration (\sum 1) doesn't care about the exact value of b or a \mapsto b, just that some value exists
% % \rightarrow & \sum 1 \cdot x \cdot a \mapsto b \in location^{-1} \circ attends^{-1} \mid a = room\\
% % \rightarrow & \text{Missing collapse of x and b?} \\
% \leadsto & \langle \text{Membership collapse*} [x, y, S, P, E := x, a \mapsto b, location^{-1} \circ attends^{-1}, a = room,b] \rangle\\
% & \sum x = b \land a \mapsto b \in location^{-1} \circ attends^{-1} \land a = room \mid 1\\
% \leadsto & \langle \text{Composition } [Q,R := location^{-1}, attends^{-1}] \rangle\\
% & \sum a \mapsto c \in location^{-1} \land c' \mapsto b \in attends^{-1} \land a = room \land c = c' \mid 1\\
% \leadsto & \langle \text{Inverse } [R := location, R:= attends] \rangle\\
% % & \sum c \mapsto a \in location \land b \mapsto c' \in attends \land a = room \land c = c' \mid 1\\
% % \rightarrow & \langle \text{Promoting non-generating conditions (built-in to the rewrite rules, not strict)} \rangle\\
% & \sum c \mapsto a \in location \land b \mapsto c' \in attends \land a = room \land c = c' \mid 1\\
% \leadsto & \langle \text{Summation } [x,S,P,E := c \mapsto a, location, b \mapsto c' \in attends \land a = room,1] \rangle\\
% &
% \begin{minipage}[]{.7\textwidth}
% \begin{algorithmic}
%     \State $c := 0$
%     \For{$c \mapsto a$ in $location$}
%         \If{$b \mapsto c$ in $attends$ and $a = room$ and $c = c'$}
%             \State $c := c + 1$
%         \EndIf
%     \EndFor
% \end{algorithmic}
% \end{minipage}\\
% \leadsto & \langle \text{Composed conditional } [P,x,S,Q := a = room, b \mapsto c, attends, c = c'] \rangle\\
% &
% \begin{minipage}[]{.7\textwidth}
% \begin{algorithmic}
%     \State $c := 0$
%     \For{$c \mapsto a$ in $location$}
%         \If{$a = room$}
%             \For{$b \mapsto c$ in $attends$}
%                 \If{$c = c'$}
%                     \State $c := c + 1$
%                 \EndIf
%             \EndFor
%         \EndIf
%     \EndFor
% \end{algorithmic}
% \end{minipage}
% \end{align*}
\end{document}
