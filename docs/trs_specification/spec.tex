\documentclass{article}

\usepackage[T1]{fontenc}
\usepackage{amsmath, amsthm}
\usepackage{amssymb}
\usepackage{listings}
\usepackage[svgnames]{xcolor}
\usepackage{tikz}
\usepackage{array}
\usepackage{graphicx}
\usepackage[backend=biber, maxbibnames=9]{biblatex}
\usepackage{algpseudocode}
\usepackage{algorithm}
\usepackage{mathtools}
\usepackage{xcolor}
\usepackage{subcaption}
\usepackage{wrapfig}
\usepackage{hhline}
\usepackage{bsymb}
\usepackage{hyperref}

% Commands
% Simple set comprehension notation
\newcommand{\Set}[2]{%
  \{\, #1 \mid #2 \, \}%
}
% Event-B-like set notation
\newcommand{\bSet}[3]{%
  \{\, #1 \cdot #2 \mid #3 \, \}%
}
\newcommand{\bSetT}[2]{%
  \{\, #1 \cdot #2 \,\}%
}

% List comprehension notation
\newcommand{\List}[3]{%
  [\, #1 \cdot #2 \mid #3 \, ]%
}
\newcommand{\ListT}[2]{%
  [\, #1 \cdot #2 \, ]%
}
% List concatenation
\newcommand{\concat}{%
  \mathbin{{+}\mspace{-8mu}{+}}%
}

% Other preamble
\graphicspath{{./images/}}
% NOTE: need to run `biber <name>` to ensure up-to-date references
\addbibresource{spec.bib}

\title{Complete TRS Specification for Abstract Collection Types}
\author{Anthony Hunt}

\begin{document}
\maketitle
\tableofcontents
\newpage

\section{Introduction}
This document serves as a living specification of the underlying term rewriting system used in the compiler for a modelling-focused programming language.

\section{High Level Strategy}

\paragraph{General Strategy}
A basic strategy to optimize set and relational expressions is:
\begin{enumerate}
  \item Normalize the expression as a set comprehensions
  \item Simplify and reorganize conjuncts of the set comprehension body
\end{enumerate}

\paragraph{Intuition}
The TRS for this language primarily involves lowering collection data type expressions into pointwise boolean quantifications. Breaking down each operation into set builder notation enables a few key actions:
\begin{itemize}
  \item Quantifications over sets ($\bSet{x}{G}{P}$) are naturally separated into generators ($G$) and (non-generating) predicates ($P$). For sets, at least one membership operator per top-level conjunction in $G$ will serve as a concrete element generator in generated code. Then, top level disjunctions will select one membership operation to act as a generator, relegating all others to the predicate level. For example, if the rewrite system observes an intersection of the form $\bSetT{x}{x \in S \land x \in T}$, the set construction operation must iterate over at least one of $S$ and $T$. Then, the other will act as a condition to check every iteration (becoming $\bSet{x}{x \in S}{x \in T}$).
  \item By definition of generators in quantification notation, operations in $G$ must be statements of the form $x \in S$, where $x$ is used in the ``element'' portion of the set construction. Statements like $x \notin T$ or checking a property $p(x)$ must act like conditions since they do not produce any iterable elements.
  \item Any boolean expression for conditions may be rewritten as a combination of $\lnot, \lor$, and $\land$ expressions. Therefore, by converting all set notation down into boolean notation and then generating code based on set constructor booleans, we can accommodate any form of predicate function.
\end{itemize}


\paragraph{Granular Strategy (Sets)}
% TODO take from report.tex, give supporting equations too (all the rules must be stable first)

\section{Supported Operations}
\begin{table}[H]
    \centering
    \caption{Summary table: a few operators on sets and relations.}
    \begin{tabular}{|c|c||c|c|}
    \hhline{|--||--|}
    \multicolumn{2}{|c||}{Sets} & \multicolumn{2}{|c|}{Relations} \\
    \hhline{:==::==:}
    Syntax & Label/Description & Syntax & Label/Description\\
    \hhline{|--||--|}
    $set(T)$ & Unordered, unique collection             & $S \pfun T$ & Partial function \\
    $S \leftrightarrow T$ & Relation, $set(S\times T)$  & $S \tinj T$& Total injection\\
    $\emptyset$ & Empty set                             & $a \mapsto b$ & Pair (relational element) \\
    $\{a,b,...\}$ & Set enumeration                     & $dom(S)$ & Domain\\
    $\bSet{x}{x \in S}{P}$ & Set comprehension          & $ran(S)$ & Range\\
    $S \cup T$ & Union                                  & $R[S]$ & Relational image\\
    $S \cap T$ & Intersection                           & $R \ovl Q$ & Relational overriding\\
    $S \setminus T$ & Difference                        & $R \circ Q$ & Relational composition\\
    $S \times T$ & Cartesian Product                    & $S \triangleleft R$ & Domain restriction\\
    $S \subseteq T$ & Subset                            & $R^{-1}$ & Relational inverse\\
    \hhline{|--||--|}
    % $f(S)$ & Function application\\ % is this like function mapping over a set? do we need to include this?
    \end{tabular}
    \label{tab:ADTOps}
\end{table}
\begin{table}[H]
    \centering
    \caption{Collection of operators on set data types.}
    \begin{tabular}{|c|c|}
        \hline
        Name & Definition \\ %& Type &
        \hline
        Empty Set & Creates a set with no elements.\\ %& $\emptyset: set[]$ &
        Set Enumeration & Literal collection of elements to create a set.\\ %& $\{x, y, ...\}: set[T]$ &
        Set Membership & The term $x \in S$ is True if $x$ can be found somewhere in $S$. \\ %& $\in: T \times set[T] \rightarrow bool$ &
        \hline
        Union & $S \cup T = \bSetT{x}{x \in S \lor x \in T}$ \\ %& $\cup: set[T] \times set[T] \rightarrow set[T]$ &
        Intersection & $S \cap T = \bSetT{x}{x \in S \land x \in T}$ \\ %& $\cap: set[T] \times set[T] \rightarrow set[T]$ &
        Difference & $S \setminus T = \bSet{x}{x \in S}{x \notin T}$ \\ %& $\setminus: set[T] \times set[T] \rightarrow set[T]$ &
        Cartesian Product & $S \times T = \bSetT{x \mapsto y}{x \in S \land y \in T}$ \\ %& $\times: set[T] \times set[V] \rightarrow relation[T,V]$ &
        \hline
        Powerset & $\mathbb{P}(S) = \bSetT{s}{s \subseteq S }$ \\ %& $\mathbb{P}: set[T] \rightarrow set[set[T]]$&
        Magnitude & $\#S = \sum_{x \in S} 1$\\ %& $\#:set[T] \rightarrow int$ &
        Subset & $S \subseteq T \equiv \forall x \in S: s \in T$ \\ %& $\subseteq: set[T] \times set[T] \rightarrow bool$ &
        Strict Subset & $S \subset T \equiv S \subseteq T \land S \neq T$ \\ %& $\subset: set[T] \times set[T] \rightarrow bool$ &
        Superset & $S \supseteq T \equiv \forall x \in T: s \in S$ \\ %& $\supseteq: set[T] \times set[T] \rightarrow bool$ &
        Strict Superset & $S \supset T \equiv S \supseteq T \land S \neq T$ \\ %& $\supset: set[T] \times set[T] \rightarrow bool$ &
        \hline
        Set Mapping & $f * S = \bSetT{f(x)}{x \in S}$\\ %& $*: (T \rightarrow T') \times set[T] \rightarrow set[T']$ &
        Set Filter & $p \triangleleft S = \bSet{x}{x \in S}{p(x)}$\\ %& $\triangleleft: (T \rightarrow bool) \times set[T] \rightarrow set[T]$ &
        % Reduction & $f / S = $ %& $/:(T\times T \rightarrow T) \times set[T] \rightarrow T$ &
        Set Quantification (Folding) & $\oplus x \cdot x \in S \mid P$\\
        Cardinality & $card(S) = \sum 1 \cdot x \in S$\\
        \hline
    \end{tabular}
    \label{tab:setOps}
\end{table}
\begin{table}[H]
    \centering
    \caption{Collection of operators on sequence data types.}
    \begin{tabular}{|c|c|}
        \hline
        Name & Definition \\ %& Type &
        \hline
        Empty List & Creates a list with no elements.\\ %& $[]: list[]$ &
        List Enumeration & Literal collection of elements to create a list.\\ %& $[x, y, ...]: list[T]$ &
        Construction & Alternative form of List Enumeration.\\ %& $(:):T \times list[T] \rightarrow list[T]$ &
        List Membership & The term $x \texttt{ in } S$ is True if $x$ can be found somewhere in $S$. \\ %& $\texttt{in}: T \times list[T] \rightarrow bool$ &
        \hline
        Append & $[s_1, s_2, ..., s_n] + t = [s_1, s_2, ..., s_n, t]$ \\ %& $+: list[T] \times T \rightarrow list[T]$ &
        Concatenate & $[s_1, ..., s_n] \concat [t_1, ..., t_n] = [s_1, ..., s_n, t_1, ... t_n]$ \\ %& $\concat: list[T] \times list[T] \rightarrow list[T]$ &
        Length & $\#S = \sum 1 \cdot x \texttt{ in } S$ \\ %& $\#: list[T] \rightarrow int$ &
        \hline
        List Mapping & $f * S = \ListT{f(x)}{x \texttt{ in } S}$\\ %& $*: (T \rightarrow T') \times list[T] \rightarrow list[T']$ &
        List Filter & $p \triangleleft S = \List{f(x)}{x \texttt{ in } S}{p(x)}$\\ %& $\triangleleft: (T \rightarrow bool) \times list[T] \rightarrow list[T]$ &
        Associative Reduction & $\oplus / [s_1, s_2, ..., s_n] = s_1 \oplus s_2 \oplus ... \oplus s_n$\\ %& $/:(T\times T \rightarrow T) \times list[T] \rightarrow T$ &
        Right Fold & $\texttt{foldr}(f, e, [s_1, s_2, ..., s_n]) = f(s_1 ,f(s_2 , f(..., f(s_n, e))))$\\ %& $\texttt{foldr}:(T\times V \rightarrow V) \times V \times list[T] \rightarrow V$ &
        Left Fold & $\texttt{foldl}(f, e, [s_1, s_2, ..., s_n]) = f(f(f(f(e, s_1), s_2), ...), s_n)$\\ %& $\texttt{foldl}:(T\times T \rightarrow T) \times list[T] \rightarrow T$ &
        \hline
    \end{tabular}
    \label{tab:seqOps}
\end{table}
\begin{table}[H]
    \centering
    \caption{Collection of operators on relation data types.}
    \begin{tabular}{|c|c|}
        \hline
        Name & Definition \\ %& Type &
        \hline
        Empty Relation & Creates a relation with no elements.\\ %& $\{\}:relation[]$ &
        Relation Enumeration & Literal collection of elements to create a relation.\\ %& $\{x \mapsto y, a \mapsto b,...\}: relation[T, V]$ &
        Identity & $id(S)= \bSetT{x \mapsto x}{x \in S}$\\ %& $id: set[T] \rightarrow relation[T,T]$ &
        Domain & $dom(R) = \bSetT{x}{x \mapsto y \in R}$\\ %& $dom: relation[T,V] \rightarrow set[T]$ &
        Range & $ran(R) = \bSetT{y}{x \mapsto y \in R}$\\ %& $ran: relation[T,V] \rightarrow set[V]$ &
        \hline
        Relational Image & $R[S] = \bSet{y}{x \mapsto y \in R}{x \in S}$ \\ %& $([]): relation[T,V] \times set[T] \rightarrow set[V]$ &
        Overriding & $R \ovl Q = Q \cup (dom(Q) \domsub R)$\\ %\Set{x \mapsto y}{x\mapsto y \in Q \lor (x \mapsto y \in R \land x \notin dom(Q))}$ \\ %& $\ovl: relation[T,V] \times relation[T,V] \rightarrow relation[T,V]$ &
        (Forward) Composition & $Q \circ R = \bSetT{x \mapsto z}{x \mapsto y \in R \land y \mapsto z \in Q}$\\ %& $\circ: relation[V,W] \times relation[T,V] \rightarrow relation[T,W]$ &
        Inverse & $R^{-1} = \bSetT{y \mapsto x}{x \mapsto y \in R}$ \\ %& $(^{-1}): relation[T,V] \rightarrow relation[V,T]$ &
        \hline
        Domain Restriction & $S \triangleleft R = \bSet{x \mapsto y}{x \mapsto y \in R}{x \in S}$\\ %& $\triangleleft: set[T] \times relation[T,V] \rightarrow relation[T,V]$ &
        Domain Subtraction & $S \domsub R = \bSet{x \mapsto y}{x \mapsto y \in R}{x \notin S}$\\ %& $\domsub: set[T] \times relation[T,V] \rightarrow relation[T,V]$ &
        Range Restriction & $R \triangleright S = \bSet{x \mapsto y}{x \mapsto y \in R}{y \in S}$\\ %& $\triangleright: set[V] \times relation[T,V] \rightarrow relation[T,V]$ &
        Range Subtraction & $R \ransub S = \bSet{x \mapsto y}{x \mapsto y \in R}{y \notin S}$\\ %& $\ransub: set[V] \times relation[T,V] \rightarrow relation[T,V]$ &
        % \hline % Do we need to include tests for total, surjective, injective, etc.?
        % Eventually add closures
        \hline
    \end{tabular}
    \label{tab:relOps}
\end{table}
\section{Rules}
\subsection{Sets}
\subsection{Relations}
\subsection{Lists}


\end{document}