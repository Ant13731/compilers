\documentclass{article}

\usepackage[T1]{fontenc}
\usepackage{amsmath, amsthm}
\usepackage{amssymb}
\usepackage{listings}
\usepackage[svgnames]{xcolor}
\usepackage{tikz}
\usepackage{array}
\usepackage{graphicx}
\usepackage[backend=biber, maxbibnames=9]{biblatex}
\usepackage[noend]{algpseudocode}
\usepackage{algorithm}
\usepackage{mathtools}
\usepackage{xcolor}
\usepackage{subcaption}
\usepackage{wrapfig}
\usepackage{hhline}
\usepackage{bsymb}
\usepackage{hyperref}

% Commands
% Simple set comprehension notation
\newcommand{\Set}[2]{%
  \{\, #1 \mid #2 \, \}%
}
% Event-B-like set notation
\newcommand{\bSet}[3]{%
  \{\, #1 \cdot #2 \mid #3 \, \}%
}
\newcommand{\bSetT}[2]{%
  \{\, #1 \cdot #2 \,\}%
}

% Bag notation
\newcommand{\lbbar}{\{\kern-0.5ex|}
\newcommand{\rbbar}{|\kern-0.5ex\}}
\newcommand{\bag}[3]{%
  \lbbar \, #1 \cdot #2 \mid #3 \, \rbbar%
}
\newcommand{\bagT}[2]{%
  \lbbar \, #1 \cdot #2 \,\rbbar%
}

% List comprehension notation
\newcommand{\List}[3]{%
  [\, #1 \cdot #2 \mid #3 \, ]%
}
\newcommand{\ListT}[2]{%
  [\, #1 \cdot #2 \, ]%
}
% List concatenation
\newcommand{\concat}{%
  \mathbin{{+}\mspace{-8mu}{+}}%
}

% From https://tex.stackexchange.com/questions/82782/footnote-in-align-environment
\makeatletter
\let\original@footnote\footnote
\newcommand{\align@footnote}[1]{%
  \ifmeasuring@
    \chardef\@tempfn=\value{footnote}%
    \footnotemark
    \setcounter{footnote}{\@tempfn}%
  \else
    \iffirstchoice@
      \original@footnote{#1}%
    \fi
  \fi}
\pretocmd{\start@align}{\let\footnote\align@footnote}{}{}
\makeatother

% Other preamble
\allowdisplaybreaks
\graphicspath{{./images/}}
% NOTE: need to run `biber <name>` to ensure up-to-date references
\addbibresource{spec.bib}

\title{Complete TRS Specification for Abstract Collection Types}
\author{Anthony Hunt}

\begin{document}
\maketitle
\tableofcontents
\newpage

\section{Introduction}
This document serves as a living specification of the underlying term rewriting system used in the compiler for a modelling-focused programming language.

\section{High Level Strategy}

\paragraph{General Strategy}
A basic strategy to optimize set and relational expressions is:
\begin{enumerate}
  \item Normalize the expression as a set comprehensions
  \item Simplify and reorganize conjuncts of the set comprehension body
\end{enumerate}

\paragraph{Intuition}
The TRS for this language primarily involves lowering collection data type expressions into pointwise boolean quantifications. Breaking down each operation into set builder notation enables a few key actions:
\begin{itemize}
  \item Quantifications over sets ($\bSet{x}{G}{P}$) are naturally separated into generators ($G$) and (non-generating) predicates ($P$). For sets, at least one membership operator per top-level conjunction in $G$ will serve as a concrete element generator in generated code. Then, top level disjunctions will select one membership operation to act as a generator, relegating all others to the predicate level. For example, if the rewrite system observes an intersection of the form $\bSetT{x}{x \in S \land x \in T}$, the set construction operation must iterate over at least one of $S$ and $T$. Then, the other will act as a condition to check every iteration (becoming $\bSet{x}{x \in S}{x \in T}$).
  \item By definition of generators in quantification notation, operations in $G$ must be statements of the form $x \in S$, where $x$ is used in the ``element'' portion of the set construction. Statements like $x \notin T$ or checking a property $p(x)$ must act like conditions since they do not produce any iterable elements.
  \item Any boolean expression for conditions may be rewritten as a combination of $\lnot, \lor$, and $\land$ expressions. Therefore, by converting all set notation down into boolean notation and then generating code based on set constructor booleans, we can accommodate any form of predicate function.
\end{itemize}


\paragraph{Granular Strategy (Sets)}
% TODO take from report.tex, give supporting equations too (all the rules must be stable first)
\begin{description}
  \item[Set Comprehension Construction] Break down all qualifying sets into comprehension forms, collapsing and simplifying where needed.
  \item[DNF Predicates] Revise comprehension predicates to top-level disjunctive normal form. Each or-clause should have at least one feasible generator. Each clause should record a list of candidate generators
  \item[Predicate Simplification] Remove superfluous dummy variables, group or-clauses that use the exact same generator (ex. $\bSetT{x}{x \in S \land x \neq 0 \lor x \in S \land x = 0} \rightarrow \bSetT{x}{x \in S \land (x \neq 0 \lor x = 0)}$). Clauses should be group-able based on DNF, and generators should be selected and recorded.
  \item[Set Code Generation] Converts quantifiers into for-loops and if-statements.
\end{description}

\section{Supported Operations}
\begin{table}[H]
    \centering
    \caption{Summary table: a few operators on sets and relations.}
    \begin{tabular}{|c|c||c|c|}
    \hhline{|--||--|}
    \multicolumn{2}{|c||}{Sets} & \multicolumn{2}{|c|}{Relations} \\
    \hhline{:==::==:}
    Syntax & Label/Description & Syntax & Label/Description\\
    \hhline{|--||--|}
    $set(T)$ & Unordered, unique collection             & $S \pfun T$ & Partial function \\
    $S \leftrightarrow T$ & Relation, $set(S\times T)$  & $S \tinj T$& Total injection\\
    $\emptyset$ & Empty set                             & $a \mapsto b$ & Pair (relational element) \\
    $\{a,b,...\}$ & Set enumeration                     & $dom(S)$ & Domain\\
    $\bSet{x}{x \in S}{P}$ & Set comprehension          & $ran(S)$ & Range\\
    $S \cup T$ & Union                                  & $R[S]$ & Relational image\\
    $S \cap T$ & Intersection                           & $R \ovl Q$ & Relational overriding\\
    $S \setminus T$ & Difference                        & $R \circ Q$ & Relational composition\\
    $S \times T$ & Cartesian Product                    & $S \triangleleft R$ & Domain restriction\\
    $S \subseteq T$ & Subset                            & $R^{-1}$ & Relational inverse\\
    \hhline{|--||--|}
    % $f(S)$ & Function application\\ % is this like function mapping over a set? do we need to include this?
    \end{tabular}
    \label{tab:ADTOps}
\end{table}
\begin{table}[H]
    \centering
    \caption{Collection of operators on set data types.}
    \begin{tabular}{|c|c|}
        \hline
        Name & Definition \\ %& Type &
        \hline
        Empty Set & Creates a set with no elements.\\ %& $\emptyset: set[]$ &
        Set Enumeration & Literal collection of elements to create a set.\\ %& $\{x, y, ...\}: set[T]$ &
        Set Membership & The term $x \in S$ is True if $x$ can be found somewhere in $S$. \\ %& $\in: T \times set[T] \rightarrow bool$ &
        \hline
        Union & $S \cup T = \bSetT{x}{x \in S \lor x \in T}$ \\ %& $\cup: set[T] \times set[T] \rightarrow set[T]$ &
        Intersection & $S \cap T = \bSetT{x}{x \in S \land x \in T}$ \\ %& $\cap: set[T] \times set[T] \rightarrow set[T]$ &
        Difference & $S \setminus T = \bSet{x}{x \in S}{x \notin T}$ \\ %& $\setminus: set[T] \times set[T] \rightarrow set[T]$ &
        Cartesian Product & $S \times T = \bSetT{x \mapsto y}{x \in S \land y \in T}$ \\ %& $\times: set[T] \times set[V] \rightarrow relation[T,V]$ &
        \hline
        Powerset & $\mathbb{P}(S) = \bSetT{s}{s \subseteq S }$ \\ %& $\mathbb{P}: set[T] \rightarrow set[set[T]]$&
        Magnitude & $\#S = \sum_{x \in S} 1$\\ %& $\#:set[T] \rightarrow int$ &
        Subset & $S \subseteq T \equiv \forall x \in S: s \in T$ \\ %& $\subseteq: set[T] \times set[T] \rightarrow bool$ &
        Strict Subset & $S \subset T \equiv S \subseteq T \land S \neq T$ \\ %& $\subset: set[T] \times set[T] \rightarrow bool$ &
        Superset & $S \supseteq T \equiv \forall x \in T: s \in S$ \\ %& $\supseteq: set[T] \times set[T] \rightarrow bool$ &
        Strict Superset & $S \supset T \equiv S \supseteq T \land S \neq T$ \\ %& $\supset: set[T] \times set[T] \rightarrow bool$ &
        \hline
        Set Mapping & $f * S = \bSetT{f(x)}{x \in S}$\\ %& $*: (T \rightarrow T') \times set[T] \rightarrow set[T']$ &
        Set Filter & $p \triangleleft S = \bSet{x}{x \in S}{p(x)}$\\ %& $\triangleleft: (T \rightarrow bool) \times set[T] \rightarrow set[T]$ &
        % Reduction & $f / S = $ %& $/:(T\times T \rightarrow T) \times set[T] \rightarrow T$ &
        Set Quantification (Folding) & $\oplus x \cdot x \in S \mid P$\\
        Cardinality & $card(S) = \sum 1 \cdot x \in S$\\
        \hline
    \end{tabular}
    \label{tab:setOps}
\end{table}
\begin{table}[H]
    \centering
    \caption{Collection of operators on bag/multiset data types.}
    \begin{tabular}{|c|c|}
        \hline
        Name & Definition \\ %& Type &
        \hline
        Empty Set & Creates a set with no elements.\\ %& $\emptyset: set[]$ &
        Bag Enumeration & Literal collection of elements to create a set \\ & (for now, stored as a tuple of elements and number of occurrences).\\ %& $\{x, y, ...\}: set[T]$ &
        Bag Membership & The term $x \in S$ is True if $S$ contains one or more occurrences of $x$. \\ %& $\in: T \times set[T] \rightarrow bool$ &
        \hline
        Union & $S \cup T = \bag{(x, a+b)}{(x,a) \in S \land (x,b) \in T}{a, b \geq 0}$ \\ %& $\cup: set[T] \times set[T] \rightarrow set[T]$ &
        Intersection & $S \cap T = \bag{(x, min(a,b))}{(x,a) \in S \land (x,b) \in T}{a, b \geq 0}$ \\ %& $\cap: set[T] \times set[T] \rightarrow set[T]$ &
        Difference & $S - T = \bag{(x, a-b)}{(x,a) \in S \land (x,b) \in T}{a, b \geq 0 \land a-b > 0}$ \\ %& $\setminus: set[T] \times set[T] \rightarrow set[T]$ &
        % Cartesian Product & $S \times T = \bSetT{x \mapsto y}{x \in S \land y \in T}$ \\ %& $\times: set[T] \times set[V] \rightarrow relation[T,V]$ &
        % \hline
        % Powerset & $\mathbb{P}(S) = \bSetT{s}{s \subseteq S }$ \\ %& $\mathbb{P}: set[T] \rightarrow set[set[T]]$&
        % Magnitude & $\#S = \sum_{x \in S} 1$\\ %& $\#:set[T] \rightarrow int$ &
        % Subset & $S \subseteq T \equiv \forall x \in S: s \in T$ \\ %& $\subseteq: set[T] \times set[T] \rightarrow bool$ &
        % Strict Subset & $S \subset T \equiv S \subseteq T \land S \neq T$ \\ %& $\subset: set[T] \times set[T] \rightarrow bool$ &
        % Superset & $S \supseteq T \equiv \forall x \in T: s \in S$ \\ %& $\supseteq: set[T] \times set[T] \rightarrow bool$ &
        % Strict Superset & $S \supset T \equiv S \supseteq T \land S \neq T$ \\ %& $\supset: set[T] \times set[T] \rightarrow bool$ &
        % \hline
        Bag Mapping & $f * S = \bagT{(f(x), r)}{(x, r) \in S}$\\ %& $*: (T \rightarrow T') \times set[T] \rightarrow set[T']$ &
        Bag Filter & $p \triangleleft S = \bag{(x, r)}{(x, r) \in S}{p(x)}$\\ %& $\triangleleft: (T \rightarrow bool)
        Size & $size(S) = \sum r \cdot (x, r) \in S$\\
        Zero Occurrences & $(x,0) \in S \implies x \notin S$\\
        \hline
    \end{tabular}
    \label{tab:setOps}
\end{table}
\begin{table}[H]
    \centering
    \caption{Collection of operators on sequence data types.}
    \begin{tabular}{|c|c|}
        \hline
        Name & Definition \\ %& Type &
        \hline
        Empty List & Creates a list with no elements.\\ %& $[]: list[]$ &
        List Enumeration & Literal collection of elements to create a list.\\ %& $[x, y, ...]: list[T]$ &
        Construction & Alternative form of List Enumeration.\\ %& $(:):T \times list[T] \rightarrow list[T]$ &
        List Membership & The term $x \texttt{ in } S$ is True if $x$ can be found somewhere in $S$. \\ %& $\texttt{in}: T \times list[T] \rightarrow bool$ &
        \hline
        Append & $[s_1, s_2, ..., s_n] + t = [s_1, s_2, ..., s_n, t]$ \\ %& $+: list[T] \times T \rightarrow list[T]$ &
        Concatenate & $[s_1, ..., s_n] \concat [t_1, ..., t_n] = [s_1, ..., s_n, t_1, ... t_n]$ \\ %& $\concat: list[T] \times list[T] \rightarrow list[T]$ &
        Length & $\#S = \sum 1 \cdot x \texttt{ in } S$ \\ %& $\#: list[T] \rightarrow int$ &
        \hline
        List Mapping & $f * S = \ListT{f(x)}{x \texttt{ in } S}$\\ %& $*: (T \rightarrow T') \times list[T] \rightarrow list[T']$ &
        List Filter & $p \triangleleft S = \List{f(x)}{x \texttt{ in } S}{p(x)}$\\ %& $\triangleleft: (T \rightarrow bool) \times list[T] \rightarrow list[T]$ &
        Associative Reduction & $\oplus / [s_1, s_2, ..., s_n] = s_1 \oplus s_2 \oplus ... \oplus s_n$\\ %& $/:(T\times T \rightarrow T) \times list[T] \rightarrow T$ &
        Right Fold & $\texttt{foldr}(f, e, [s_1, s_2, ..., s_n]) = f(s_1 ,f(s_2 , f(..., f(s_n, e))))$\\ %& $\texttt{foldr}:(T\times V \rightarrow V) \times V \times list[T] \rightarrow V$ &
        Left Fold & $\texttt{foldl}(f, e, [s_1, s_2, ..., s_n]) = f(f(f(f(e, s_1), s_2), ...), s_n)$\\ %& $\texttt{foldl}:(T\times T \rightarrow T) \times list[T] \rightarrow T$ &
        \hline
    \end{tabular}
    \label{tab:seqOps}
\end{table}
\begin{table}[H]
    \centering
    \caption{Collection of operators on relation data types.}
    \begin{tabular}{|c|c|}
        \hline
        Name & Definition \\ %& Type &
        \hline
        Empty Relation & Creates a relation with no elements.\\ %& $\{\}:relation[]$ &
        Relation Enumeration & Literal collection of elements to create a relation.\\ %& $\{x \mapsto y, a \mapsto b,...\}: relation[T, V]$ &
        Identity & $id(S)= \bSetT{x \mapsto x}{x \in S}$\\ %& $id: set[T] \rightarrow relation[T,T]$ &
        Domain & $dom(R) = \bSetT{x}{x \mapsto y \in R}$\\ %& $dom: relation[T,V] \rightarrow set[T]$ &
        Range & $ran(R) = \bSetT{y}{x \mapsto y \in R}$\\ %& $ran: relation[T,V] \rightarrow set[V]$ &
        \hline
        Relational Image & $R[S] = \bSet{y}{x \mapsto y \in R}{x \in S}$ \\ %& $([]): relation[T,V] \times set[T] \rightarrow set[V]$ &
        Overriding & $R \ovl Q = Q \cup (dom(Q) \domsub R)$\\ %\Set{x \mapsto y}{x\mapsto y \in Q \lor (x \mapsto y \in R \land x \notin dom(Q))}$ \\ %& $\ovl: relation[T,V] \times relation[T,V] \rightarrow relation[T,V]$ &
        (Forward) Composition & $Q \circ R = \bSetT{x \mapsto z}{x \mapsto y \in R \land y \mapsto z \in Q}$\\ %& $\circ: relation[V,W] \times relation[T,V] \rightarrow relation[T,W]$ &
        Inverse & $R^{-1} = \bSetT{y \mapsto x}{x \mapsto y \in R}$ \\ %& $(^{-1}): relation[T,V] \rightarrow relation[V,T]$ &
        \hline
        Domain Restriction & $S \triangleleft R = \bSet{x \mapsto y}{x \mapsto y \in R}{x \in S}$\\ %& $\triangleleft: set[T] \times relation[T,V] \rightarrow relation[T,V]$ &
        Domain Subtraction & $S \domsub R = \bSet{x \mapsto y}{x \mapsto y \in R}{x \notin S}$\\ %& $\domsub: set[T] \times relation[T,V] \rightarrow relation[T,V]$ &
        Range Restriction & $R \triangleright S = \bSet{x \mapsto y}{x \mapsto y \in R}{y \in S}$\\ %& $\triangleright: set[V] \times relation[T,V] \rightarrow relation[T,V]$ &
        Range Subtraction & $R \ransub S = \bSet{x \mapsto y}{x \mapsto y \in R}{y \notin S}$\\ %& $\ransub: set[V] \times relation[T,V] \rightarrow relation[T,V]$ &
        % \hline % Do we need to include tests for total, surjective, injective, etc.?
        % Eventually add closures
        \hline
    \end{tabular}
    \label{tab:relOps}
\end{table}

\section{Relational Subtypes}
The notion of a relation is a broad classification of a set of pairs, where the domain, range, and relationship are not bound by any conditions. However, when generating code based on purely mathematical relations, it can be advantageous to use notions of totality, injectivity, surjectivity, etc. In particular, these named relational subtypes can be described with four properties: total on the domain, total on the range, one-to-many, and many-to-one.

The below table converts conventional notation into these four subtypes:
\begin{table}[H]
  \centering\begin{tabular}{|c|c|c|c|c|}
    \hline
    Relational Subtype & \multicolumn{4}{c|}{Properties}\\
    & T & TR & 1- & 1-R\\
    \hline
    Relation & & & & \\
     & & & & \checkmark \\
    Partial Function & & & \checkmark & \\
    Partial Injection & & & \checkmark & \checkmark \\
    Surjective Relation & & \checkmark & & \\
     & & \checkmark & & \checkmark \\
    Partial Surjection & & \checkmark & \checkmark & \\
     & & \checkmark & \checkmark & \checkmark \\
    Total Relation & \checkmark & & & \\
     & \checkmark & & & \checkmark \\
    Total Function & \checkmark & & \checkmark & \\
    Total Injection & \checkmark & & \checkmark & \checkmark \\
    Total Surjective Relation & \checkmark & \checkmark & & \\
     & \checkmark & \checkmark & & \checkmark \\
    Total Surjection & \checkmark & \checkmark & \checkmark & \\
    Bijection & \checkmark & \checkmark & \checkmark & \checkmark \\
    % Relation & \\
    % Total Relation & T \\
    % Surjective Relation & TR \\
    % Total Surjective Relation & T, TR \\
    % Partial Function & 1-\\
    % Total Function & T, 1-\\
    % Partial Injection & 1-, 1-R\\
    % Total Injection & T, 1-, 1-R\\
    % Partial Surjection & TR, 1-\\
    % Total Surjection & T, TR, 1-\\
    % Bijection & T, TR, 1-, 1-R\\
    % Should we consider Partial Bijection too?
    % Partial Bijection  & \\
    \hline
  \end{tabular}
  \caption{Conventional mathematical notation of relational subtypes decomposed into four properties: domain totality (T), range totality (TR), domain one-to-manyness (1-), and range one-to-manyness (1-R)}
  \label{tab:relSubtype}
\end{table}

\subsection{Properties}
Properties that can affect code generation may involve:
\begin{itemize}
  \item New properties after applying operations on sets/relations
  \item Size of result
  \item Validity of operations
  \item Deterministic nature of operations
  \item Super/subset properties
  \item Relational identities
\end{itemize}
%
Below is a list of the impact of these properties.
\\
Domain Totality:
\begin{itemize}
  \item $R[S] \neq \emptyset$
  \item $R(S)$ is always valid
  \item $R^{-1}$ is TR
  \item $|R| \geq dom(R)$
\end{itemize}
%
Range Totality:
\begin{itemize}
  \item $R^{-1}$ is T
  \item $|R| \geq ran(R)$
\end{itemize}
%
Domain One-to-manyness:
\begin{itemize}
  \item $R(\{e\})$ is deterministic
  \item $|R[\{e\}]| = 1$
  \item $|R[S]| \leq |S|$
  \item $|R| \leq dom(R)$
\end{itemize}
%
Range One-to-manyness:
\begin{itemize}
  \item $|R| \leq ran(R)$
\end{itemize}


\section{Rules}
Below is a list of rewrite rules for key abstract data types, syntactic sugar, and some builtin functions. Phases are intended to be executed in order; the post-condition of one phase serves as the pre-condition for the next.

\subsection{Syntactic Sugar for Bags}
\begin{align}
  \tag{Bag Image}
  R[B]
  &\leadsto
  R^{-1} \circ B
  \\
  \tag{Bag Predicates - Union}
  S \cup T &\leadsto \bag{x}{x \in dom(S) \cup dom(T) \land n = max(S[x] \cup T[x])}{x \mapsto n}
  \\
  \tag{Bag Predicates - Intersection}
  S \cap T &\leadsto \bag{x}{x \in dom(S) \cap dom(T) \land n = min(S[x] \cup T[x]) \land n > 0}{x \mapsto n}
  \\
  \tag{Bag Predicates - Sum}
  S + T &\leadsto \bag{x}{x \in dom(S) \cup dom(T) \land n = sum(S[x] \cup T[x])}{x \mapsto n}
  \\
  \tag{Bag Predicates - Difference}
  S - T &\leadsto \bag{x}{x \in dom(S) \land pop(S[x]) - popDefault(T[x], 0) \land n > 0}{x \mapsto n}
\end{align}
\subsection{Builtin Functions}

\noindent\begin{minipage}{\linewidth}
\begin{align}
  \tag{Cardinality}
  card(S)
  &\leadsto
  \sum x \cdot x \in S \mid 1
  \\
  \tag{Domain}
  dom(R)
  &\leadsto
  \bSet{x \mapsto y}{x \mapsto y \in R}{x}
  \\
  \tag{Range}
  ran(R)
  &\leadsto
  \bSet{x \mapsto y}{x \mapsto y \in R}{y}
  \\
  \tag{Override}
  R \ovl Q &\leadsto Q \cup (dom(Q) \domsub R)
  \\
  \tag{Domain Restriction}
  S \triangleleft R &\leadsto \bSet{x\mapsto y}{x \mapsto y \in R \land x \in S}{x \mapsto y}
  \\
  \tag{Domain Subtraction}
  S \domsub R &\leadsto \bSet{x\mapsto y}{x \mapsto y \in R \land x \notin S}{x \mapsto y}
  \\
  \tag{Range Restriction}
  R \triangleright S &\leadsto \bSet{x\mapsto y}{x \mapsto y \in R \land y \in S}{x \mapsto y}
  \\
  \tag{Range Subtraction}
  R \ransub S &\leadsto \bSet{x\mapsto y}{x \mapsto y \in R \land y \notin S}{x \mapsto y}
  \\
  \tag{Bag Size}
  size(S) &\leadsto \sum x \mapsto n \in S \cdot n
\end{align}
\end{minipage}
\subsection{Sets}

Let $S,T$ be sets, $P, E$ expressions, and $x, e$ any type.
\subsubsection{Comprehension Construction}

\paragraph{Intuition} All set-like variables and literals are decomposed into set comprehensions.

\paragraph{Post-condition}
\begin{itemize}
  \item All terms with a set-like type (relations, bags, sets, sequences, etc.) must be in comprehension form.
\end{itemize}


\noindent\begin{minipage}{\linewidth}
\begin{align}
  \tag{Functional Image \footnote{May fail if R is not total.}}
  R(x) &\leadsto pop(R[x])
  \\
  \tag{Image}
  R[S] &\leadsto \bSet{x \mapsto y}{x \mapsto y \in R \land x \in S}{y}
  \\
  \tag{Product}
  x \mapsto y \in S \times T &\leadsto x \in S \land y \in T
  \\
  \tag{Inverse}
  x \mapsto y \in R^{-1} &\leadsto y \mapsto x \in R
  \\
  \tag{Composition}
  x \mapsto y \in (Q \circ R) &\leadsto x \mapsto z \in Q \land z' \mapsto y \in R \land z=z'
  \\
  % \tag{Exists Elimination}
  % \exists z \cdot x \mapsto z \in Q \land z \mapsto y \in R &\leadsto x \mapsto z \in Q \land z' \mapsto y \in R \land z=z'
  % \\
  \end{align}
\end{minipage}
\noindent\begin{minipage}{\linewidth}
\begin{align}
  \tag{Predicate Operations - Union}
  S \cup T
  &\leadsto
  \bSetT{x}{x \in S \lor x \in T}
  \\
  \tag{Predicate Operations - Intersection}
  S \cap T
  &\leadsto
  \bSetT{x}{x \in S \land x \in T}
  \\
  \tag{Predicate Operations - Difference}
  S \setminus T
  &\leadsto
  \bSetT{x}{x \in S \land x \notin T}
  \\
  \tag{Singleton Membership \footnote{Currently unused. We need to be careful to handle the case where $x$ is a free variable.}}
  x \in \{e\}
  &\leadsto
  x = e
  \\
  \tag{Membership Collapse \footnote{Rule only matches inside the predicate of a quantifier. Explicitly enumerating all matches for all quantuantification types and predicate cases (ANDs, ORs, etc.) would require too much boilerplate. $x$ must be bound by the encasing quantifier.\\
  The $\oplus$ operator represents any quantifier that returns a set-like type (ex. generalized union/intersection, set comprehension, relation comprehension).}}
  x \in \oplus(E \mid P)
  &\leadsto
  P \land x = E
\end{align}
\end{minipage}

\subsubsection{Disjunctive Normal Form}

\paragraph{Intuition} All quantifier predicates are expanded to DNF (i.e. $\land$-operations nested within top-level $\lor$-operations).

\paragraph{Notes} All matches of this phase occur only inside quantifier predicates.

\paragraph{Post-condition}
\begin{itemize}
  \item All terms with a set-like type (relations, bags, sets, sequences, etc.) must be in comprehension form.
  \item Quantifier predicates are in disjunctive normal form - top level or-clauses with inner and-clauses.
  \item If no $\lor$ operators exist within a quantifier predicate, the predicate must only contain $\land$ operators.
\end{itemize}

% https://en.wikipedia.org/wiki/Disjunctive_normal_form
\noindent\begin{minipage}{\linewidth} % Need minipage for footnote
\begin{align}
  \tag{Flatten Nested $\land$}
  x_1 \land ... \land (x_i \land x_{i+1}) \land ...
  &\leadsto
  x_1 \land ... \land x_i \land x_{i+1} \land ...
  \\
  \tag{Flatten Nested $\lor$}
  x_1 \lor ... \lor (x_i \lor x_{i+1}) \lor ...
  &\leadsto
  x_1 \lor ... \lor x_i \lor x_{i+1} \lor ...
  \\
  \tag{Double Negation}
  \lnot \lnot x
  &\leadsto
  x
  \\
  \tag{Distribute De Morgan - Or}
  \lnot (x \lor y)
  &\leadsto
  \lnot x \land \lnot y
  \\
  \tag{Distribute De Morgan - And}
  \lnot (x \land y)
  &\leadsto
  \lnot x \lor \lnot y
  \\
  \tag{Distribute $\land$ over $\lor$}
  x \land (y \lor z)
  &\leadsto
  (x \land y) \lor (x \land z)
\end{align}
\end{minipage}

\subsubsection{Or-wrapping}
\paragraph{Intuition} Restructuring quantifier predicates with top-level ORs for later rules.

\paragraph{Post-condition}
\begin{itemize}
  \item All terms with a set-like type (relations, bags, sets, sequences, etc.) must be in comprehension form.
  \item Quantifier predicates are in disjunctive normal form - top level or-clauses with inner and-clauses.
\end{itemize}

\noindent\begin{minipage}{\linewidth}
\begin{align}
  \tag{Or-wrapping \footnote{To simplify the matching process later on, we wrap every top-level AND statement (which is guaranteed to be a ListOp by the dataclass field type definition) with an OR.}}
  \bSetT{E}{\bigwedge P_i}
  &\leadsto
  \bSetT{E}{\bigvee \bigwedge P_i}
\end{align}
\end{minipage}

\subsubsection{Generator Selection}
\paragraph{Intuition} All nested ANDs are placed in a tree structure to better suit loop lowering.

\paragraph{Post-condition}
\begin{itemize}
  \item All terms with a set-like type (relations, bags, sets, sequences, etc.) must be in comprehension form.
  \item Each top-level or-clause within quantification predicates must have one selected `generator' predicate (GeneratorSelectionPredicate - GSP) of the form $x \in S$ that loops over its bound dummy variable $x$.
  \item All conjunctive clauses are wrapped in either a GSP or CombGSP structure.
  \item Quantifier predicates are in disjunctive normal form (with GSP replacing AND structures) - top level or-clauses with inner and-clauses.
\end{itemize}

\paragraph{Notes} All matches of this phase occur only inside quantifier predicates. GSP is a tuple of form (generator chain, predicates) that can be flattened to a conjunctive clause. A CombGSP is a triple of form (shared generator, disjunctive children predicates/generators, predicates) that can likewise be flattened into a conjunctive clause. We keep the structure of these tuples distinct to ease the rewriting process.

\paragraph{Brainstorming selection heuristics}
Conditions to consider:
\begin{itemize}
  \item Prefer composition chains in case of nested loops (ex. $x \mapsto y \in R \land y \mapsto z \in Q$, but what about renaming? - $x \mapsto y \in R \land y' \mapsto z \in Q \land y = y'$). Perhaps this could just be a preference for relations over sets if we see a nested quantifier.
  \item Choose most common generator among a list of or-clauses (allows for greater simplification later on)
  \item Choose smallest generator (by set size). This information may not always be accessible (ex. if a set is created by reading values from standard input). Functions may need to choose this on a case-by-case basis (ie. one function call could have two args, with a small set on the left arg and a large set on the right arg. But what if the sizes are reversed later in the code? We've already statically lowered it).
  \item When should constant folding happen? Equality substitution necessary for this?
  \item This may need to work with nesting considerations.
  \item What if we try moving these optimizations to $loop$ structures far later in the pipeline?
\end{itemize}

\noindent\begin{minipage}{\linewidth}
\begin{align}
  \tag{GSP Wrapping \footnote{GSP is a tuple-like structure, where all entries can be flattened into an AND. The LH term must occur inside a quantifier's predicate - one generator per top-level or-clause. Chained generators may be necessary to allow for nested loop operations (ie. non-top-level clauses may require generators). $P_g$ is a list of chained generators, specific set membership clauses (of form $x \in S$) distinguished from the rest of $\bigwedge P_i$. Currently, the selection of $P_g$ is arbitrary (and thus the rewrite system is not confluent), but heurestics may be added later to choose better generators.}}
  \bigwedge P_i
  &\leadsto
  GSP(\bigwedge P_{g_i}, \bigwedge_{P_i \notin P_g} P_i)
  \\
  \tag{Nested Generator Selection \footnote{$free$ is a function that returns true when variables in the predicate are defined (either bound by the current generator or bound prior to the current statement)}}
  GSP(x \land xs, P) \lor GSP(x \land ys, Q)
  &\leadsto
  CombGSP(x, GSP(xs, P) \lor GSP(ys, Q))
\end{align}
\end{minipage}



\subsubsection{GSP to Loop}

\paragraph{Intuition} Start lowering expressions into imperative-like loops.

\paragraph{Post-condition}
\begin{itemize}
  \item All quantifiers are transformed into $loop$ structures.
  \item $loop$ predicates are of the form $x \in S \land \bigwedge P_i$.
  \item All $loop$ predicates have an assigned generator of the form $x \in S$.
\end{itemize}

\noindent\begin{minipage}{\linewidth}
\begin{align}
  \tag{Quantifier Generation \footnote{$\oplus$ works for any quantifier (but not $\forall$ and $\exists$). The identity and accumulate functions are determined by the realized $\oplus$. For example, if $\oplus = \sum$, the identity is 0 and accumulate is addition.}}
  \oplus E \mid P
  &\leadsto
  \begin{minipage}[]{0.4\textwidth}
  \begin{algorithmic}
  \State $a := identity(\oplus)$
    \Loop\ $P:$ % should we use the \in operator here, or just plaintext in?
        \State $a := accumulate(a, E)$
    \EndLoop
  \end{algorithmic}
  \end{minipage}
\end{align}
\end{minipage}
% \noindent\begin{minipage}{\linewidth}
% \begin{align}
%   \tag{Nested Quantifier}
%   \begin{minipage}[]{0.5\textwidth}
%   \begin{algorithmic}
%     \State $a := accumulator(a, \oplus(E \mid P))$
%   \end{algorithmic}
%   \end{minipage}
%   &\leadsto
%   \begin{minipage}[]{0.4\textwidth}
%   \begin{algorithmic}
%     \Loop\ $P:$
%       \State $a := accumulator(a, E)$
%     \EndLoop
%   \end{algorithmic}
%   \end{minipage}
% \end{align}
% \end{minipage}
\noindent\begin{minipage}{\linewidth}
\begin{align}
  \tag{Top-level Or-Loop}
  \begin{minipage}[]{0.3\textwidth}
  \begin{algorithmic}
    \Loop\ $\bigvee P_i:$
      \State body
    \EndLoop
  \end{algorithmic}
  \end{minipage}
  &\leadsto
  \begin{minipage}[]{0.5\textwidth}
  \begin{algorithmic}
    \Loop\ $P_0$
      \State $body$
    \EndLoop
    \Loop\ $P_1 \land \lnot P_0$
      \State $body$
    \EndLoop
    \Loop\ $P_2 \land \lnot \bigvee_{i < 2} P_i$
      \State $body$
    \EndLoop
  \end{algorithmic}
  \end{minipage}
\end{align}
\end{minipage}
%
\noindent\begin{minipage}{\linewidth}
\begin{align}
  \tag{Chained GSP Loop \footnote{$free$ considers defined variables at this point in time.}}
  \begin{minipage}[]{0.4\textwidth}
  \begin{algorithmic}
    \Loop\ $GSP(g \land gs, P)$
      \State body
    \EndLoop
  \end{algorithmic}
  \end{minipage}
  &\leadsto
  \begin{minipage}[]{0.4\textwidth}
  \begin{algorithmic}
    \Loop\ $SingleGSP(g, free(P))$
      \Loop\ $GSP(gs, bound(P))$
        \State body
      \EndLoop
    \EndLoop
  \end{algorithmic}
  \end{minipage}
\end{align}
\end{minipage}
%
% \noindent\begin{minipage}{\linewidth}
% \begin{align}
%   \tag{Single GSP Loop}
%   \begin{minipage}[]{0.4\textwidth}
%   \begin{algorithmic}
%     \Loop\ $GSP(g, P)$
%       \State body
%     \EndLoop
%   \end{algorithmic}
%   \end{minipage}
%   &\leadsto
%   \begin{minipage}[]{0.4\textwidth}
%   \begin{algorithmic}
%     \Loop\ $SingleGSP(g, P)$
%       \State body
%     \EndLoop
%   \end{algorithmic}
%   \end{minipage}
% \end{align}
% \end{minipage}
%
\noindent\begin{minipage}{\linewidth}
\begin{align}
  \tag{Empty GSP Loop}
  \begin{minipage}[]{0.4\textwidth}
  \begin{algorithmic}
    \Loop\ $GSP([], P)$
      \State body
    \EndLoop
  \end{algorithmic}
  \end{minipage}
  &\leadsto
  \begin{minipage}[]{0.4\textwidth}
  \begin{algorithmic}
    \If{$P$}
      \State body
    \EndIf
  \end{algorithmic}
  \end{minipage}
\end{align}
\end{minipage}
%
\noindent\begin{minipage}{\linewidth}
\begin{align}
  \tag{Combined GSP Loop}
  \begin{minipage}[]{0.4\textwidth}
  \begin{algorithmic}
    \Loop\ $CombGSP(g, gs, P)$
      \State body
    \EndLoop
  \end{algorithmic}
  \end{minipage}
  &\leadsto
  \begin{minipage}[]{0.4\textwidth}
  \begin{algorithmic}
    \Loop\ $SingleGSP(g, P)$
      \Loop\ $gs_0$
        \State body
      \EndLoop
      \Loop\ $gs_1$
        \State body
      \EndLoop
      \State ...
    \EndLoop
  \end{algorithmic}
  \end{minipage}
\end{align}
\end{minipage}

% \noindent\begin{minipage}{\linewidth}
% \begin{align}
%   \tag{Disjunct conditional}
%   \begin{minipage}[]{0.33\textwidth}
%   \begin{algorithmic}
%     \Loop\ $\bigvee GSP_i(P_{g_i}, P_i)$
%       \State body
%     \EndLoop
%   \end{algorithmic}
%   \end{minipage}
%   &\leadsto
%   \begin{minipage}[]{0.5\textwidth}
%   \begin{algorithmic}
%     \Loop\ $GSP_0(P_{g_0}, P_0):$
%       \State body
%     \EndLoop
%     \Loop\ $GSP_1(P_{g_1}, P_1 \land \lnot GSP_0):$
%       \State body
%     \EndLoop
%     \Loop\ $GSP_2(P_{g_2}, P_2 \land \lnot (\bigvee_{i < 2} GSP_i)):$
%       \State body
%     \EndLoop
%     \State ...
%   \end{algorithmic}
%   \end{minipage}
%   \\
%   \tag{Disjunct Conditional 2}
%   \begin{minipage}[]{0.3\textwidth}
%   \begin{algorithmic}
%     \Loop\ $GSP(P_g, \bigvee P_i)$
%       \State body
%     \EndLoop
%   \end{algorithmic}
%   \end{minipage}
%   &\leadsto
%   \begin{minipage}[]{0.8\textwidth}
%   \begin{algorithmic}
%     \Loop\ $GSP(P_g, \bigwedge True):$
%       \If{$\bigvee_{ P_i \neq GSP(...)} P_i$}
%         \State body
%       \EndIf
%       \Loop\ $\bigvee_{P_i: GSP(P_{ig}, P_{is})} GSP(P_{g_i}, P_{is} \land \lnot \bigvee_{P_i \neq GSP(...)} P_i):$
%         \State body
%       \EndLoop
%     \EndLoop
%   \end{algorithmic}
%   \end{minipage}
% \end{align}
% \end{minipage}

\subsubsection{Relational Subtyping Loop Simplification}

\paragraph{Intuition} Simplify unnecessary iteration structures into direct accesses.

\paragraph{Post-condition}
\begin{itemize}
  \item All quantifiers are transformed into $loop$ structures.
  \item $loop$ predicates are of the form $x \in S \land \bigwedge P_i$.
  \item All $loop$ predicates have an assigned generator of the form $x \in S$.
\end{itemize}
No change from previous, but the number of loop structures should not increase.

\noindent\begin{minipage}{\linewidth}
\begin{align}
  \tag{Total membership elimination \footnote{$R$ is total and $x$ satisfies the type of $R$'s domain}}
  x \in dom(R)
  &\leadsto
  True
  \\
  \tag{Surjective membership elimination \footnote{$R$ is surjective and $x$ satisfies the type of $R$'s range}}
  x \in ran(R)
  &\leadsto
  True
\end{align}
\end{minipage}
\noindent\begin{minipage}{\linewidth}
\begin{align}
  \tag{Concrete Domain Image}
  \begin{minipage}[]{0.55\textwidth}
  \begin{algorithmic}
    \Loop\ $SingleGSP(x \mapsto y \in R, x = a \land P)$
      \State body
    \EndLoop
  \end{algorithmic}
  \end{minipage}
  &\leadsto
  \begin{minipage}[]{0.6\textwidth}
  \begin{algorithmic}
    \If{$a \in dom(R)$}
      \Loop\ $SingleGSP(y \in R[a], P[x := a])$
        \State body
      \EndLoop
    \EndIf
  \end{algorithmic}
  \end{minipage}
\end{align}
\end{minipage}
\noindent\begin{minipage}{\linewidth}
\begin{align}
  \tag{Concrete Range Image \footnote{Requires efficient lookups for $ran$, inverse, and image}}
  \begin{minipage}[]{0.55\textwidth}
  \begin{algorithmic}
    \Loop\ $SingleGSP(x \mapsto y \in R, y = a \land P)$
      \State body
    \EndLoop
  \end{algorithmic}
  \end{minipage}
  &\leadsto
  \begin{minipage}[]{0.6\textwidth}
  \begin{algorithmic}
    \If{$a \in ran(R)$}
      \Loop\ $SingleGSP(x \in R^{-1}[a], P[y := a])$
        \State body
      \EndLoop
    \EndIf
  \end{algorithmic}
  \end{minipage}
\end{align}
\end{minipage}
\noindent\begin{minipage}{\linewidth}
\begin{align}
  \tag{Single Element Loop}
  \begin{minipage}[]{0.5\textwidth}
  \begin{algorithmic}
    \Loop\ $SingleGSP(y \in R[x], P)$
      \State body
    \EndLoop
  \end{algorithmic}
  \text{where $free(x)$ and $R$ is many-to-one}
  \end{minipage}
  &\leadsto
  \begin{minipage}[]{0.5\textwidth}
  \begin{algorithmic}
    \If{$P[y:=R(a)]$}
      \State $body[y:=R(a)]$
    \EndIf
  \end{algorithmic}
  \end{minipage}
\end{align}
\end{minipage}

\subsubsection{Loop Code Generation}

\paragraph{Intuition} Eliminate all intermediate loop structures.

\paragraph{Post-condition}
\begin{itemize}
  \item AST is in imperative code style (for loops, if statements, etc).
  \item All $loop$ and quantification constructs have been eliminated.
  \item Some variables may not be defined.
\end{itemize}

\noindent\begin{minipage}{\linewidth}
\begin{align}
  \tag{Conjunct Conditional \footnote{Function $free$ returns clauses in $P$ that contain only free + defined variables. $bound$ returns the clauses that contain the bound variable $x$ or undefined variables. $P_g$ is the selected generator.}}
  \begin{minipage}[]{0.4\textwidth}
  \begin{algorithmic}
    \Loop\ $SingleGSP(P_g, \bigwedge P_i)$
      \State body
    \EndLoop
  \end{algorithmic}
  \end{minipage}
  &\leadsto
  \begin{minipage}[]{0.5\textwidth}
  \begin{algorithmic}
    \If{$\bigwedge_{free(P_i)} P_i$}
      \For{$P_g$}
        % \State $P_as$ % TODO rewrite these to be more clear that they are assignments
        \If{$\bigwedge_{bound(P_i)} P_i$}
            \State body
          % \If{$Q_0$}
          %   \State body
          % \EndIf
          % \If{$Q_1 \land \lnot Q_0$}
          %   \State body
          % \EndIf
          % \If{$Q_2 \land \lnot (\bigvee_{i < 2} Q_i)$}
          %   \State body
          % \EndIf
          % \State ...
        \EndIf
      \EndFor
    \EndIf
  \end{algorithmic}
  \end{minipage}
\end{align}
\end{minipage}



\subsubsection{Replace and Simplify}

\paragraph{Intuition} Eliminate all undefined variables (with implicit $\exists$ quantifiers).

\paragraph{Post-condition}
\begin{itemize}
  \item AST is in imperative code style (for loops, if statements, etc).
  \item All variables are defined.
\end{itemize}

\noindent\begin{minipage}{\linewidth}
\begin{align}
  \tag{Equality Elimination \footnote{$x$ is an undefined, unbound variable in the current scope. $E$ is an expression that does not contain $x$. Simplify resulting booleans.}}
  \begin{minipage}[]{0.5\textwidth}
  \begin{algorithmic}
    \If{$Identifier(x) = E \land P$}
      \State body
    \EndIf
  \end{algorithmic}
  \end{minipage}
  &\leadsto
  \begin{minipage}[]{0.4\textwidth}
  \begin{algorithmic}
    \If{$P[x := E]$}
      \State body[x := E]
    \EndIf
  \end{algorithmic}
  \end{minipage}
\end{align}
\end{minipage}
%
\noindent\begin{minipage}{\linewidth}
\begin{align}
  \tag{Simplify And-true}
  P \land True
  &\leadsto
  P
  \\
  \tag{Simplify And-false}
  P \land False
  &\leadsto
  False
  \\
  \tag{Simplify Or-true}
  P \lor True
  &\leadsto
  True
  \\
  \tag{Simplify Or-false}
  P \lor False
  &\leadsto
  P
  \\
  \tag{Flatten Nested Statements}
  Statement(Statement(x))
  &\leadsto
  Statement(x)
\end{align}
\end{minipage}

% TODO:
% \subsection{Lists}

\section{Implementation Representation}
Different implementations of each data type will have varying strengths and weaknesses, not only in theoretical asymptotic time and space, but in concrete real-world tests. Cache usage and additional information through object metadata may prove influential on smaller tests. Since this document is only concerned with the theoretical compiler specification, we analyze the theoretical time and space complexity, then pair gathered examples with a test plan for hardware considerations.

A first approach to tackling these type representations would likely constitute a linked list. The space requirements for enumeration are straightforward, with extra allocations for link pointers. Insertions for unordered collections or append/concat operations are $O(1)$, but $O(n)$ for indexed insertion and union with one element. Lookups for all collections are $O(n)$, but this running time is undesirable for the often-used \texttt{in} operator for set-generated code. Since linked lists naturally enforce element order, this structure may be suitable for fast-changing sequences. Although, a limited-size sequence may be better suited for a contiguous array for $O(1)$ indexing. \textit{TODO: For sequences, we should also see if trees/heaps or bloom filters could provide efficient membership checking. Bloom filters are probabilistic but can determine $\neq$ operations.}

On the other hand, hashmaps with $O(1)$ membership and element lookups are useful for all unordered collections. Relations may need bidirectional hashmaps that can efficiently handle many-to-many relations.

Compressed bitmaps may be used for sets, but require a lot of space for sparse elements.

Bags may be implemented either as a (linked) list, a set of tuples where the number of element occurrences is stored in the second tuple component, or a relation where the number of occurrences is the codomain.

\end{document}