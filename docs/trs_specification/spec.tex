\documentclass{article}

\usepackage[T1]{fontenc}
\usepackage{amsmath, amsthm}
\usepackage{amssymb}
\usepackage{listings}
\usepackage[svgnames]{xcolor}
\usepackage{tikz}
\usepackage{array}
\usepackage{graphicx}
\usepackage[backend=biber, maxbibnames=9]{biblatex}
\usepackage[noend]{algpseudocode}
\usepackage{algorithm}
\usepackage{mathtools}
\usepackage{xcolor}
\usepackage{subcaption}
\usepackage{wrapfig}
\usepackage{hhline}
\usepackage{bsymb}
\usepackage{hyperref}

% Commands
% Simple set comprehension notation
\newcommand{\Set}[2]{%
  \{\, #1 \mid #2 \, \}%
}
% Event-B-like set notation
\newcommand{\bSet}[3]{%
  \{\, #1 \cdot #2 \mid #3 \, \}%
}
\newcommand{\bSetT}[2]{%
  \{\, #1 \cdot #2 \,\}%
}

% List comprehension notation
\newcommand{\List}[3]{%
  [\, #1 \cdot #2 \mid #3 \, ]%
}
\newcommand{\ListT}[2]{%
  [\, #1 \cdot #2 \, ]%
}
% List concatenation
\newcommand{\concat}{%
  \mathbin{{+}\mspace{-8mu}{+}}%
}

% Other preamble
\allowdisplaybreaks
\graphicspath{{./images/}}
% NOTE: need to run `biber <name>` to ensure up-to-date references
\addbibresource{spec.bib}

\title{Complete TRS Specification for Abstract Collection Types}
\author{Anthony Hunt}

\begin{document}
\maketitle
\tableofcontents
\newpage

\section{Introduction}
This document serves as a living specification of the underlying term rewriting system used in the compiler for a modelling-focused programming language.

\section{High Level Strategy}

\paragraph{General Strategy}
A basic strategy to optimize set and relational expressions is:
\begin{enumerate}
  \item Normalize the expression as a set comprehensions
  \item Simplify and reorganize conjuncts of the set comprehension body
\end{enumerate}

\paragraph{Intuition}
The TRS for this language primarily involves lowering collection data type expressions into pointwise boolean quantifications. Breaking down each operation into set builder notation enables a few key actions:
\begin{itemize}
  \item Quantifications over sets ($\bSet{x}{G}{P}$) are naturally separated into generators ($G$) and (non-generating) predicates ($P$). For sets, at least one membership operator per top-level conjunction in $G$ will serve as a concrete element generator in generated code. Then, top level disjunctions will select one membership operation to act as a generator, relegating all others to the predicate level. For example, if the rewrite system observes an intersection of the form $\bSetT{x}{x \in S \land x \in T}$, the set construction operation must iterate over at least one of $S$ and $T$. Then, the other will act as a condition to check every iteration (becoming $\bSet{x}{x \in S}{x \in T}$).
  \item By definition of generators in quantification notation, operations in $G$ must be statements of the form $x \in S$, where $x$ is used in the ``element'' portion of the set construction. Statements like $x \notin T$ or checking a property $p(x)$ must act like conditions since they do not produce any iterable elements.
  \item Any boolean expression for conditions may be rewritten as a combination of $\lnot, \lor$, and $\land$ expressions. Therefore, by converting all set notation down into boolean notation and then generating code based on set constructor booleans, we can accommodate any form of predicate function.
\end{itemize}


\paragraph{Granular Strategy (Sets)}
% TODO take from report.tex, give supporting equations too (all the rules must be stable first)

\section{Supported Operations}
\begin{table}[H]
    \centering
    \caption{Summary table: a few operators on sets and relations.}
    \begin{tabular}{|c|c||c|c|}
    \hhline{|--||--|}
    \multicolumn{2}{|c||}{Sets} & \multicolumn{2}{|c|}{Relations} \\
    \hhline{:==::==:}
    Syntax & Label/Description & Syntax & Label/Description\\
    \hhline{|--||--|}
    $set(T)$ & Unordered, unique collection             & $S \pfun T$ & Partial function \\
    $S \leftrightarrow T$ & Relation, $set(S\times T)$  & $S \tinj T$& Total injection\\
    $\emptyset$ & Empty set                             & $a \mapsto b$ & Pair (relational element) \\
    $\{a,b,...\}$ & Set enumeration                     & $dom(S)$ & Domain\\
    $\bSet{x}{x \in S}{P}$ & Set comprehension          & $ran(S)$ & Range\\
    $S \cup T$ & Union                                  & $R[S]$ & Relational image\\
    $S \cap T$ & Intersection                           & $R \ovl Q$ & Relational overriding\\
    $S \setminus T$ & Difference                        & $R \circ Q$ & Relational composition\\
    $S \times T$ & Cartesian Product                    & $S \triangleleft R$ & Domain restriction\\
    $S \subseteq T$ & Subset                            & $R^{-1}$ & Relational inverse\\
    \hhline{|--||--|}
    % $f(S)$ & Function application\\ % is this like function mapping over a set? do we need to include this?
    \end{tabular}
    \label{tab:ADTOps}
\end{table}
\begin{table}[H]
    \centering
    \caption{Collection of operators on set data types.}
    \begin{tabular}{|c|c|}
        \hline
        Name & Definition \\ %& Type &
        \hline
        Empty Set & Creates a set with no elements.\\ %& $\emptyset: set[]$ &
        Set Enumeration & Literal collection of elements to create a set.\\ %& $\{x, y, ...\}: set[T]$ &
        Set Membership & The term $x \in S$ is True if $x$ can be found somewhere in $S$. \\ %& $\in: T \times set[T] \rightarrow bool$ &
        \hline
        Union & $S \cup T = \bSetT{x}{x \in S \lor x \in T}$ \\ %& $\cup: set[T] \times set[T] \rightarrow set[T]$ &
        Intersection & $S \cap T = \bSetT{x}{x \in S \land x \in T}$ \\ %& $\cap: set[T] \times set[T] \rightarrow set[T]$ &
        Difference & $S \setminus T = \bSet{x}{x \in S}{x \notin T}$ \\ %& $\setminus: set[T] \times set[T] \rightarrow set[T]$ &
        Cartesian Product & $S \times T = \bSetT{x \mapsto y}{x \in S \land y \in T}$ \\ %& $\times: set[T] \times set[V] \rightarrow relation[T,V]$ &
        \hline
        Powerset & $\mathbb{P}(S) = \bSetT{s}{s \subseteq S }$ \\ %& $\mathbb{P}: set[T] \rightarrow set[set[T]]$&
        Magnitude & $\#S = \sum_{x \in S} 1$\\ %& $\#:set[T] \rightarrow int$ &
        Subset & $S \subseteq T \equiv \forall x \in S: s \in T$ \\ %& $\subseteq: set[T] \times set[T] \rightarrow bool$ &
        Strict Subset & $S \subset T \equiv S \subseteq T \land S \neq T$ \\ %& $\subset: set[T] \times set[T] \rightarrow bool$ &
        Superset & $S \supseteq T \equiv \forall x \in T: s \in S$ \\ %& $\supseteq: set[T] \times set[T] \rightarrow bool$ &
        Strict Superset & $S \supset T \equiv S \supseteq T \land S \neq T$ \\ %& $\supset: set[T] \times set[T] \rightarrow bool$ &
        \hline
        Set Mapping & $f * S = \bSetT{f(x)}{x \in S}$\\ %& $*: (T \rightarrow T') \times set[T] \rightarrow set[T']$ &
        Set Filter & $p \triangleleft S = \bSet{x}{x \in S}{p(x)}$\\ %& $\triangleleft: (T \rightarrow bool) \times set[T] \rightarrow set[T]$ &
        % Reduction & $f / S = $ %& $/:(T\times T \rightarrow T) \times set[T] \rightarrow T$ &
        Set Quantification (Folding) & $\oplus x \cdot x \in S \mid P$\\
        Cardinality & $card(S) = \sum 1 \cdot x \in S$\\
        \hline
    \end{tabular}
    \label{tab:setOps}
\end{table}
\begin{table}[H]
    \centering
    \caption{Collection of operators on sequence data types.}
    \begin{tabular}{|c|c|}
        \hline
        Name & Definition \\ %& Type &
        \hline
        Empty List & Creates a list with no elements.\\ %& $[]: list[]$ &
        List Enumeration & Literal collection of elements to create a list.\\ %& $[x, y, ...]: list[T]$ &
        Construction & Alternative form of List Enumeration.\\ %& $(:):T \times list[T] \rightarrow list[T]$ &
        List Membership & The term $x \texttt{ in } S$ is True if $x$ can be found somewhere in $S$. \\ %& $\texttt{in}: T \times list[T] \rightarrow bool$ &
        \hline
        Append & $[s_1, s_2, ..., s_n] + t = [s_1, s_2, ..., s_n, t]$ \\ %& $+: list[T] \times T \rightarrow list[T]$ &
        Concatenate & $[s_1, ..., s_n] \concat [t_1, ..., t_n] = [s_1, ..., s_n, t_1, ... t_n]$ \\ %& $\concat: list[T] \times list[T] \rightarrow list[T]$ &
        Length & $\#S = \sum 1 \cdot x \texttt{ in } S$ \\ %& $\#: list[T] \rightarrow int$ &
        \hline
        List Mapping & $f * S = \ListT{f(x)}{x \texttt{ in } S}$\\ %& $*: (T \rightarrow T') \times list[T] \rightarrow list[T']$ &
        List Filter & $p \triangleleft S = \List{f(x)}{x \texttt{ in } S}{p(x)}$\\ %& $\triangleleft: (T \rightarrow bool) \times list[T] \rightarrow list[T]$ &
        Associative Reduction & $\oplus / [s_1, s_2, ..., s_n] = s_1 \oplus s_2 \oplus ... \oplus s_n$\\ %& $/:(T\times T \rightarrow T) \times list[T] \rightarrow T$ &
        Right Fold & $\texttt{foldr}(f, e, [s_1, s_2, ..., s_n]) = f(s_1 ,f(s_2 , f(..., f(s_n, e))))$\\ %& $\texttt{foldr}:(T\times V \rightarrow V) \times V \times list[T] \rightarrow V$ &
        Left Fold & $\texttt{foldl}(f, e, [s_1, s_2, ..., s_n]) = f(f(f(f(e, s_1), s_2), ...), s_n)$\\ %& $\texttt{foldl}:(T\times T \rightarrow T) \times list[T] \rightarrow T$ &
        \hline
    \end{tabular}
    \label{tab:seqOps}
\end{table}
\begin{table}[H]
    \centering
    \caption{Collection of operators on relation data types.}
    \begin{tabular}{|c|c|}
        \hline
        Name & Definition \\ %& Type &
        \hline
        Empty Relation & Creates a relation with no elements.\\ %& $\{\}:relation[]$ &
        Relation Enumeration & Literal collection of elements to create a relation.\\ %& $\{x \mapsto y, a \mapsto b,...\}: relation[T, V]$ &
        Identity & $id(S)= \bSetT{x \mapsto x}{x \in S}$\\ %& $id: set[T] \rightarrow relation[T,T]$ &
        Domain & $dom(R) = \bSetT{x}{x \mapsto y \in R}$\\ %& $dom: relation[T,V] \rightarrow set[T]$ &
        Range & $ran(R) = \bSetT{y}{x \mapsto y \in R}$\\ %& $ran: relation[T,V] \rightarrow set[V]$ &
        \hline
        Relational Image & $R[S] = \bSet{y}{x \mapsto y \in R}{x \in S}$ \\ %& $([]): relation[T,V] \times set[T] \rightarrow set[V]$ &
        Overriding & $R \ovl Q = Q \cup (dom(Q) \domsub R)$\\ %\Set{x \mapsto y}{x\mapsto y \in Q \lor (x \mapsto y \in R \land x \notin dom(Q))}$ \\ %& $\ovl: relation[T,V] \times relation[T,V] \rightarrow relation[T,V]$ &
        (Forward) Composition & $Q \circ R = \bSetT{x \mapsto z}{x \mapsto y \in R \land y \mapsto z \in Q}$\\ %& $\circ: relation[V,W] \times relation[T,V] \rightarrow relation[T,W]$ &
        Inverse & $R^{-1} = \bSetT{y \mapsto x}{x \mapsto y \in R}$ \\ %& $(^{-1}): relation[T,V] \rightarrow relation[V,T]$ &
        \hline
        Domain Restriction & $S \triangleleft R = \bSet{x \mapsto y}{x \mapsto y \in R}{x \in S}$\\ %& $\triangleleft: set[T] \times relation[T,V] \rightarrow relation[T,V]$ &
        Domain Subtraction & $S \domsub R = \bSet{x \mapsto y}{x \mapsto y \in R}{x \notin S}$\\ %& $\domsub: set[T] \times relation[T,V] \rightarrow relation[T,V]$ &
        Range Restriction & $R \triangleright S = \bSet{x \mapsto y}{x \mapsto y \in R}{y \in S}$\\ %& $\triangleright: set[V] \times relation[T,V] \rightarrow relation[T,V]$ &
        Range Subtraction & $R \ransub S = \bSet{x \mapsto y}{x \mapsto y \in R}{y \notin S}$\\ %& $\ransub: set[V] \times relation[T,V] \rightarrow relation[T,V]$ &
        % \hline % Do we need to include tests for total, surjective, injective, etc.?
        % Eventually add closures
        \hline
    \end{tabular}
    \label{tab:relOps}
\end{table}

\section{Rules}
Below is a list of rewrite rules for key abstract data types.
\subsection{Sets}

% Template code rule:
% \begin{minipage}[]{.45\textwidth}
% \end{minipage}
\begin{align}
  \tag{Set Construction}
  S &\rightarrow \bSetT{x}{x \in S}
  \\
  \tag{Singleton Membership}
  x \in {e} &\rightarrow x = e
  \\
  \tag{Membership Collapse}
  f(x) \cdot x \in \bSet{g(y)}{y \in S}{P} &\rightarrow f(g(y)) \cdot y \in S \mid P
  \\
  \tag{Predicate Promotion}
  x \cdot x \in S \land p(x) &\rightarrow x \cdot x \in S \mid p(x)
  \\
  \cline{1-2}
  \tag{Union}
  x \in S \cup T &\rightarrow x \in S \lor x \in T
  \\
  \tag{Intersection}
  x \in S \cap T &\rightarrow x \in S \land x \in T
  \\
  \tag{Difference}
  x \in S \setminus T &\rightarrow x \in S \land x \notin T
  \\
  \tag{Cardinality}
  card(S) &\rightarrow \sum x \in S \cdot 1
  \\
  \cline{1-2}
  \tag{Predicate Operations}
  filter(p, S) \oplus filter(q, T) &\rightarrow \bSetT{x}{(x \in S \land p(x)) \oplus_{bool} (x \in T \land q(y))}
  % \\
  % \tag{Single Operator Mapping}
  % map(f, S) \oplus T &\rightarrow \bSetT{f(x)}{x \in S \oplus_{bool} f(x) \in T}
  \\
  \tag{Filter Over Operators}
  filter(p, S) \oplus filter(p, T) &\rightarrow filter(p, S \oplus T)
  \\
  \tag{Mapping Operations}
  map(f, S) \oplus map(g, T) &\rightarrow \bSetT{z}{(x \in S \land f(x) = z) \oplus_{bool} (x \in T \land g(y) = z)}
  \\
  \tag{Mapping Over Operators}
  map(f, S) \oplus map(f, T) &\rightarrow map(f, S \oplus T)
  \\
  \tag{Map}
  map(f, S)  &\rightarrow \bSetT{f(x)}{x \in S}
  \\
  \tag{Filter}
  filter(p, S)  &\rightarrow \bSet{x}{x \in S}{p(x)}
  \\
  \cline{1-2}
  \tag{Union Subset Simplification}
  S \cup T \text{ where } S \subseteq T &\rightarrow T
  \\
  \tag{Intersection Subset Simplification}
  S \cap T \text{ where } S \subseteq T &\rightarrow S
  \\
  \tag{Difference Subset Simplification}
  S \setminus T \text{ where } S \subseteq T &\rightarrow \emptyset
  \\
  \tag{Predicate Union with Subset}
  filter(p, S) \cup filter(q, T) \text{ where } S \subseteq T &\rightarrow filter(p \lor q, T)
  \\
  \tag{Predicate Intersection with Subset}
  filter(p, S) \cap filter(q, T) \text{ where } S \subseteq T &\rightarrow filter(p \land q, S)
  \\
  \cline{1-2}
  \tag{Set generation}
  \bSet{E}{x \in S}{P}
  &\rightarrow
  \begin{minipage}[]{0.4\textwidth}
  \begin{algorithmic}
  \State $ret := \emptyset$
  \For{$x \in S$}
      \If{$P$} % should we use the \in operator here, or just plaintext in?
          ret.append(E)
      \EndIf
  \EndFor
  \end{algorithmic}
  \end{minipage}
  \\
  \tag{Summation}
  \sum x \in S \mid P \cdot E
  &\rightarrow
  \begin{minipage}[]{0.4\textwidth}
  \begin{algorithmic}
  \State $c := 0$
  \For{$x \in S$}
      \If{$P$} % should we use the \in operator here, or just plaintext in?
          $c := c + E$
      \EndIf
  \EndFor
  \end{algorithmic}
  \end{minipage}
  \\
  \tag{Composed conditional}
  \begin{minipage}[]{0.33\textwidth}
  \begin{algorithmic}
      \If{$P \land x \in S \land Q$}
          $p$
      \EndIf
  \end{algorithmic}
  where $x$ not free in $P$
  \end{minipage}
  & \rightarrow
  \begin{minipage}[]{0.27\textwidth}
  \begin{algorithmic}
  \If{$P$}
      \For{$x \in S$}
          \If{$Q$}
              $p$
          \EndIf
      \EndFor
  \EndIf
  \end{algorithmic}
  \end{minipage}
  \\
  \tag{Conjunct conditional}
  \begin{minipage}[]{0.4\textwidth}
  \begin{algorithmic}
      \If{$P \land ((x \in S \land V) \lor W) \land Q$}
          $p$
      \EndIf
  \end{algorithmic}
  where $x$ not free in $P$
  \end{minipage}
  & \rightarrow
  \begin{minipage}[]{0.4\textwidth}
  \begin{algorithmic}
  \If{$P$}
      \For{$x \in S$}
          \If{$V \land Q$}
              $p$
          \EndIf
      \EndFor
      \If{$W \land Q$}
        $p$
      \EndIf
  \EndIf
  \end{algorithmic}
  \end{minipage}
\end{align}

Additional notes and extended context:
\begin{description}
  \item[General] When the intention is clear, operands are written in a concise variable form instead of constructor notation, although the implementation should assume that variables are fully expanded by the (Set Construction) phase. The functions $map$ and $filter$ correspond to applying a function to all elements of a set and adding a predicate to the set respectively, so $map(f,S) = \bSetT{f(x)}{x \in S}$ and $filter(p, S) = \bSet{x}{x \in S}{p(x)}$.
  \item[Membership Collapse] Assumes context of the initial term results in a valid expression. For example, this rewrite would be reasonable within a quantification statement or set construction. The intention of this rule is to simplify nested set constructions and should only be used after the (Set Construction) phase.
  \item[Predicate Promotion] If a predicate within set construction cannot be considered as a loop iterator, it is promoted to a purely conditional role. The meaning of the before and after term does not necessarily change, but it clarifies the difference between candidate generators and regular predicates.
  \item[Operations involving $\oplus$] The operator $\oplus$ represents any union, intersection, or difference operation, with $\oplus_{bool}$ representing the corresponding construction operation.
  \item[Summation] The summation operation may be replaced with any reduction/folding operation, provided the correct low-level operation. More specific forms may be needed to consider non-associative operations.
  \item[Composed Conditional] $x$ not free in $P$ means $x$ must already be bound. More clearly, no candidate generator variables that have not been defined should occur in $P$. We differentiate $P$ from $Q$ so that if-statements may leave behind predicates that are not needed in the nested loop. In the case of top-level AND-separated generators that bind to the same variable, the larger generator should be promoted to a conditional.
\end{description}

\subsection{Relations}
  \begin{align}
  \tag{Image}
  R[S] &\rightarrow \bSet{x \mapsto y \in R}{x \in S}{y}
  \\
  \tag{Product}
  x \mapsto y \in S \times T &\rightarrow x \in S \land y \in T
  \\
  \tag{Inverse}
  x \mapsto y \in R^{-1} &\rightarrow y \mapsto x \in R
  \\
  \tag{Composition}
  x \mapsto y \in (Q \circ R) &\rightarrow x \mapsto z \in Q \land z' \mapsto y \in R \land z=z'
  \\
  \tag{Override}
  R \ovl Q &\rightarrow Q \cup (dom(Q) \domsub R)
  \\
  \cline{1-2}
  \tag{Domain}
  dom(R) &\rightarrow map(fst, R)
  \\
  \tag{Range}
  ran(R) &\rightarrow map(snd, R)
  \\
  \cline{1-2}
  \tag{Domain Restriction}
  S \triangleleft R &\rightarrow filter(fst \in S, R)
  \\
  \tag{Domain Subtraction}
  S \domsub R &\rightarrow filter(fst \notin S, R)
  \\
  \tag{Range Restriction}
  S \triangleright R &\rightarrow filter(snd \in S, R)
  \\
  \tag{Range Subtraction}
  S \ransub R &\rightarrow filter(snd \notin S, R)
\end{align}

% TODO:
% \subsection{Lists}


\end{document}