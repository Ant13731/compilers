# Other TODOs
- [ ] Add input type validation to all functions (look at previous type checking in ASTNodes)
    - even if functions have a specific type hint, they still need to check for that specific type at runtime
    - cant rely on python's type checker
- [ ] restrict the allowed traits per type - eg. boolType cannot have a total_trait
    - validate this on type creation, within post_init?
- [ ] subsumption - operations should accept subtypes of input types as well
- [ ] ASTNode -> Trait (when specified with `with`)
- [ ] ASTNode -> Type
- [ ] Implement symbol table for new types
- [ ] Type implementation library


# List of typechecking rules

- [x] Env $\emptyset$
    - implicit
- [ ] Env $I$
    - symb table
- [x] Fetch Identifier
    - implicit (just lookup in the environment)
- [x] Reflexive Subtype
    - eq_type is checked for truthiness within is_sub_type
- [-] Transitive Subtype
    - will need to write tests for, equivalent for finding any B that works for types A and C
- [ ] Subsumption - TODO tomorrow!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    - need to check for subtyping when arguments are passed to functions - not just equality
- [x] Top Type
    - Use AnyType
- [x] Sub Top Type
- [x] Sub Function
    - Implement in Procedure subtyping
- [x] Sub Set
    - Implement in set
- [x] Sub Product
    - Implement in tuple
- [x] Sub Record
    - Implement in record
- [ ] Type Refinement
    - Traits should have their own type rules (value rules?) ex. T[with min=4] < T[with min=1]
    - This is implicitly true since we check for type equality, but what about when both types have traits?
        - In some cases this wouldnt be true: ex. T[with min=1] != T[with max=1]. T's are subtypes of each other but not with traits on both. When check types is invoked, we check the subtyping rules for each Trait. We further assume that if one type has a trait that the other does not, the one with the extra trait is smaller
    - note some traits imply others - set of literal ints implicitly imposes a min/max bound
- [x] Powerset
    - Implicit, sets are generic
- [x] Emptyset
    - Need to add trait Empty
- [x] Emptyset Bottom
    - implement this in the set comparison
- [x] Set Enumeration
    - add function to Set - enumeration(element_type: T) -> Set (with element type T, add in literal trait (trait will disappear once we cant be sure of the literals))
- [x] Primitives - bool
    - implicit type
- [x] Primitives - int
    - implicit type
- [x] Primitives - float
    - implicit type
- [x] Primitives - str
    - implicit type
- [ ] Nat from int
    - wont actually have a dedicated nat type - just int with traits
- [x] Int from float
    - implement in subtype function
- [x] Tuples
    - type
- [x] Empty Tuple
    - needs Empty trait
- [x] Empty Tuple Bottom
    - implement in subtype considering trait
- [x] Tuple Enumeration
    - add enumeration function like set
- [x] Relation Type
    - make Relation type inherit from Set, force element type to be a TupleType[BaseType, BaseType]
- [x] Bag Type
    - inherit from Relation type
- [x] Bag Enumeration
    - same as Set enumeration function
- [x] Sequence Type
    - inherit from Relation type
- [x] Sequence Enumeration
    - same as Set enumeration function
- [x] Enum from static set
    - needs Immutable trait
    - EnumTypeDef -> EnumType, make sure all enumtypes have the immutable trait
- [x] Relation Subtype - Total Relation
    - add traits for Total, Surjective, OneToMany, ManyToOne, follow table, maybe implement it as the mask? see how much of a hassle separate types would be
- [x] Relation Subtype - Surjective Relation
- [x] Relation Subtype - Total Surjective Relation
- [x] Relation Subtype - Partial Function
- [x] Relation Subtype - Total Function
- [x] Relation Subtype - Partial Injection
- [x] Relation Subtype - Total Injection
- [x] Relation Subtype - Partial Surjection
- [x] Relation Subtype - Total Surjection
- [x] Relation Subtype - Bijection
- [ ] Variable Assignment
    - symb table responsibility
- [ ] Type Alias Assignment
    - symb table responsibility
- [ ] Type Alias
    - Make an AliasType(underlying_type: BaseType), make it equal to the underlying_type
- [ ] Refined Variable Assignment
    - symb table resp
- [ ] Refined Type Alias
    - symb table resp
- [ ] Command - break
    - change nonetype to CommandType?
- [ ] Command - continue
- [ ] Command - skip
- [ ] Command - return
- [ ] Lambda Expression
    - use ProcedureType
- [ ] Quantification Body
    - may be worth making this a type actually, help organize the generators/move code out of the optimizer...
    - symb table impl too
    - following n-ary functions can be a part of the QuantificationBody
    - in the type hierarchy, QuantificationBody's should be dependent on the operation
    - or should this just be an additional check function in the symb table
        - Requires ASTNode as input... better to make this on the fly since it depends on the ASTNode
        - maybe just make this a method in the Quantifier ASTNode since the information fetched will be useful in the optimizer
            - this would prevent types from knowing about the quantifier construction - maybe they only need to know trait variants of this tho (ex. max/min inferred based on generator values? is this possible without pre-computation?)
- [ ] General Union
- [ ] General Intersection
- [ ] Forall
- [ ] Exists
- [ ] Set Comprehension
- [ ] Bag Comprehension
- [ ] Sequence Comprehension
- [x] Binary Boolean Operations
    - implement in BoolType
- [x] Boolean Operations - Negation
    - implement in BoolType
- [x] Equals
    - implement in BaseType
- [x] Ordering Operators
    - implement in Int, Float
- [x] Set Membership
    - implement in Set
- [x] Set Operations
    - implement in Set
- [-] Set Operations
    - needs subsetting rules?
    - implement in Set
- [x] Cartesian Product
    - implement in Set
- [x] Maplet
    - maplets should be PairType - make a function for this within PairType
- [x] Numerical Range
    - implement in Int
- [x] Set Operations - Powerset
    - implement in Set
- [x] Bag Operations - (Max) Union
    - implement in Bag
- [x] Bag Operations - Image
    - implement in Bag
- [x] Relation Operations - Function Call
    - implement in Relation
- [x] Relation Operations - Image
- [x] Relation Operations - Overriding
- [x] Relation Operations - Composition
- [x] Relation Operations - Domain Restriction
- [x] Relation Operations - Domain Subtraction
- [x] Relation Operations - Range Restriction
- [x] Relation Operations - Range Subtraction
- [x] Relational Subtype - Domain Restriction
- [x] Relational Subtype - Domain Subtraction
- [x] Relational Subtype - Range Restriction
- [x] Relational Subtype - Range Subtraction
- [x] Relational Subtype - Inverse
- [x] Relational Subtype - Overriding
- [x] Relational Subtype - Composition
- [x] Sequence Operations - Concatenation
    - implement in Sequence
- [x] Integer Operations - Division
    - implement in Int
    - make a max type global function that considers all types
- [x] Integer Operations - Modulo
- [x] Numerical Operations - Addition
    - implement in Int, Float
- [x] Numerical Operations - Subtraction
- [x] Numerical Operations - Floating Division
- [x] Numerical Operations - Multiplication
- [x] Numerical Operations - Negation
- [x] Numerical Operations - Exponentiation
- [x] Records - Access
    - impl in Record
- [x] Records - Type Definition
    - unique names implicit due to dict representation
- [ ] Records - Initialization
    - symb table
- [ ] Command - Composition
    - no types
- [x] Command - Valid Import Module
- [x] Command - Valid Import Names
- [ ] Command - Import Module
    - symb table
- [ ] Command - Import Names
    - symb table
- [ ] Command - Procedure Definition
    - symb table
- [x] Command - Procedure Call
    - impl in Procedure
- [-] Command - If
    - no types
- [-] Command - If Else
- [-] Command - While
- [-] Command - For
- [-] Command - Block
- [x] Built-in - Minimum
    - impl in Set
- [x] Built-in - Mapped Minimum
    - impl in Set
- [x] Built-in - Maximum
    - impl in Set
- [x] Built-in - Mapped Maximum
    - impl in Set
- [x] Built-in - Choice
    - impl in Set
- [x] Built-in - Domain
    - impl in Relation
- [x] Built-in - Range
    - impl in Relation
- [x] Built-in - Cardinality
    - impl in Set
- [x] Built-in - Bag Size
    - impl in Bag
- [x] Built-in - Sum (and Product)
    - impl in Set
- [x] Built-in - Cast
    - parameters swapped: T_1 x type[T_2] -> T_2
- [x] Built-in - Cast With
    - parameters swapped: T_1 x type[T_2] x list[Trait] -> T_2