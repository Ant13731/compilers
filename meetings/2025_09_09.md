# Agenda
- cgs ref letters - who to ask?
- reviewed some of the linked documents?

## Research Tasks
- Examples
    - Algorithmic/Leetcode questions often make use of sets/bags/relations
        - N-Queens question would be very nice to write via set notation
- Compiler design
    - First, sort out syntax
        - like the with syntax for choosing implementation. allows extending to refinement calc later on (with bounds and whatnot). simplifies the optimizer
    - State semantics, undefinedness behaviours, nondeterminism (see aug 26 agenda)
    - Decide data structures (with several alternatives)
        - Different atomic (efficient) operations
        - Use cases
        - Implementation details
    - Split up TRS into multiple backends, targeting different data structure types
        - Prove equiv between optimization formally, confluence, termination, etc.
    - Benchmarks/Examples comparison
        - Running time
        - Memory consumption
        - Big O results

## Compiler Tasks
- on hold: implement new design changes
- unit tests for algorithmic TRS output
- LLVM/MLIR for codegen
- check bound identifiers machinery
- get examples executing

## Backlog
- Investigate egraphs for term rewriting - see starred repo from other toy compiler
- Constant folding in TRS - when to do it?
- Dealing with subset generators and powersets
- Jupyter
    - syntax highlighting
    - kernel/server

## Thesis Planning
1. Introduction
    1. Problem Statement
    2. Contributions (simplified)
    3. Readable/understandable to anyone with a bachelors - why is this interesting, what did u solve, soln?
2. Background/Related Work (convince the reader, broad terms, contributions)
    1. Specification Languages/Specification vs Execution?
        1. Event-B
    2. Set-based languages
    3. Abstract Data Types
    4. High Level Program Optimization (and Term Rewriting)
    5. What other solns exist with a timeline, contributions expanded, define standards from other literature
3. Motivation
    1. Examples
        1. Information Systems
        2. Simulations
        3. Algorithmically-intense
4. The Simile Language (design, etc.)
5. High Level Optimization in Simile - TRS Specification
6. Implementation
    1. Jupyter
7. Conclusion
    1. Put contribution into perspective with tech details (assume paper was read)

## Requested Changes

- ⟨ and ⟩ for sequences (Z, CLRS, Back&Wright)
- [ and ] for bags, +, - for bag union, intersection (Morgan uses ∪ for forgetful union)
    - Q: Should reconsider this?:
        - sqr brackets are well known in programming languages to mean list/array/sequences, using sqr brackets for bags will be very confusing to those who know programming (not worth going against programming convention?)
        - Angled brackets more difficult to read and parse (the ascii alternative in particular, <>), takes a lot of unnecessary keypresses for such a common type?
        - would prefer the language to have valid ascii alternatives, especially for important syntax - unicode is also available for fancier notation
        - LADM uses {| |} for bags, visually similar to sets. Should we use the more formal name, multiset?
-/ ^ (Z, VDM) or + or ◦ (white circle) for sequence concatenation (Back&Wright use &)
    - using +
- /⇒ / => for implication, ⇐ / < = for consequence (short arrows)
    - Q: cant use short arrows since <= is used for lessthan/equal. can use unicode short arrows
/- ≡ / == for equivalence (not ⇔, as ≡ has the same meaning as = in typed logic, only binds weaker, but ⇔ has a different meaning)
    - Q: sounds good, but maybe just review the diff between <=> and == for my own knowledge
-/ × / * for multiplication
    - Q: what about cartesian product? Event-B >< notation? right now, left in both
- div and mod for integer division and remainder (/ is reserved for rational / real / float, % is the wrong symbol); ÷ can be synonymous to div
    - Q: % is what python/C uses, but I know that Event B uses it for lambda. Would you still prefer it be removed? I was planning on using the same symbol for integer/float addition, with automatic type loosening. If we keep /, no need for `div`?
    - For now, keeping \div, /, and replacing % with modulo
- leave out power for the time being (too complicated, likely not needed); adding exponentiation by a constant, written with superscripts, e.g. x³, is fine.
    - Q: I think leaving some ascii version of exponentiation would be desirable, either one of **/^ (ive seen both used in programming langs but okay with either). The exponentiation here will throw a type error if used on anything that's not a number, so things shouldnt be too complicated? Any concerns here? Using superscripts would make parsing more complicated... but definitely doable
- union_all → Union, intersection_all → Intersection
    - Q: maybe no capitalization? I agree with getting rid of _all
- x ↦ y is shorthand for (x, y)
    - Q: need to check with implementation on this. Should maplets be rewritten by the parser as tuples? tuple binds as tight as set notation/etc. The reason I moved maplets lower on the prcedence list is because of the mathlanguage cfg from before
-/ ⊕ for relational overwrite (even ChatGPT suggests that:-), to avoid non-Unicode
- For Total / Surjective / Total Surjective Relation, we should avoid non-Unicode symbols; try to use some combining Unicode characters or character overlays; otherwise, the least ugly solution will do it for the time being.
- := (Unicode) / := (plain text) for assignment, avoiding arrows (arrows sometimes used in algorithms, but arrows will be used elsewhere, creates unnecessary ambiguity)
-/ "true", "false" lowercase, no "None"
-/ no "elif" (not an English word), but allow "else if"
- no "struct" (misnomer originating in C; everything composed is a structure); when needed, either "T = (f: F; g: G)" or "T = record f: F; g: G end" for declaring a record; would postpone that.
- no "enum", instead "T = (Monday, Tuesday)" (Pascal, order is implied, Monday < Tuesday, used in for-loop) or "T = {Monday, Tuesday}" (B, no order implied) without keyword
    - Q: I was planning on using enum only as a type. Eg. T : enum = {"Monday", "Tuesday"}, no order implied
-/ no "def" (Python misnomer, as "functions" used to be the only thing that could be defined in Python), either "procedure" (most precise), "method" (more common), or no keyword at all for procedure definition
- no "continue" (unless there is a strong reason in intermediate forms), leave out "break" for the time being, "return" is ok
-/ "pass" (Python-specific) → "skip" (common)
-/ Syntax: I would avoid angular brackets around nonterminals; they are not needed as terminals are in quotes
    - Q: was using that bc of the grammar library, will change
- I would leave out the Comment nonterminal; if needed, easier to deal with in the scanner and more flexible, as comments can then appear anywhere
- I am unsure if we need lambda expressions; we may not allow them to be assigned to variables; they would have to be part of map, filter, etc. operations. In general, they are needed, but I would put them on the back burner
    - assigning lambdas would be very useful for providing closures (eg. in game of life, to simplify the predicate, we could define a lambda function as a drop-in-replacement expression)
-/ I am unsure about PairExpr; it should be sufficient to have tuples, not just pairs. The typing rules should clarify that; I'll get back to that.
    - Q: move down to highest precidence?
- All relation and function symbols are part of expressions here. That works in B, as it is based on set theory, but does not work typed logic. In B you can write x := A → B, which assigns to x the set of all functions from A to B. In typed logic, A → B is a type, which is different from the set of all functions of that type; types cannot be assigned to variables. The type system will sort this out.
    - Q: should we allow users to write A->B to generate the largest set satisfying the relational constraints?
- There are no local variables of the form "var x: 3 .. 5 · x := 4". While for-loops implicitly introduce a local variable, there may be other rewrite rules that explicitly introduce local variables.
    - explicit var keyword unneeded?
- There are no type declarations of the form "type T = A → B x C". In B, these are called sets; here, we would call them types.
- http://lucacardelli.name/papers/typesystems.pdf there are several papers by Cardelli on type systems. That work aims at type checking, but does not get into the meaning of terms. It is a common way of defining types and is worth reading; can you go over it and we compare it with how B presents the typing rules?
- BackVonWright98RefinementCalculus uses HOL for verification. Several sections introduce HOL, though not quite from the basics. In HOL, types are implicit and therefore mostly not given (like in functional languages). It is still worth reading those sections
- This is another exposition of HOL, but I didn't see that it starts from the basics, it jumps quickly into using Isabelle. It is an easy introduction. https://isabelle.in.tum.de/doc/tutorial.pdf
- The HOL Light system is similar to Isabelle/HOL, but as the name suggests more primitive: https://hol-light.github.io/tutorial.pdf
- The original HOL theorem prover book and John Harrison's book present HOL properly; I didn't find comparable resources online, I'll give you my copies the next time.