# Agenda
- cgs ref letters - who to ask?
- reviewed some of the linked documents?
- cdp workshop at york university - field trip?
- mention paper2audio

## Research Tasks
- Examples
    - Algorithmic/Leetcode questions often make use of sets/bags/relations
        - N-Queens question would be very nice to write via set notation
- Compiler design
    - First, sort out syntax
        - like the with syntax for choosing implementation. allows extending to refinement calc later on (with bounds and whatnot). simplifies the optimizer
    - State semantics, undefinedness behaviours, nondeterminism (see aug 26 agenda)
    - Decide data structures (with several alternatives)
        - Different atomic (efficient) operations
        - Use cases
        - Implementation details
    - Split up TRS into multiple backends, targeting different data structure types
        - Prove equiv between optimization formally, confluence, termination, etc.
    - Benchmarks/Examples comparison
        - Running time
        - Memory consumption
        - Big O results

## Compiler Tasks
- on hold: implement new design changes
- unit tests for algorithmic TRS output
- LLVM/MLIR for codegen
- check bound identifiers machinery
- get examples executing

## Backlog
- Investigate egraphs for term rewriting - see starred repo from other toy compiler
- Constant folding in TRS - when to do it?
- Dealing with subset generators and powersets
- Jupyter
    - syntax highlighting
    - kernel/server

## Thesis Planning
1. Introduction
    1. Problem Statement
    2. Contributions (simplified)
    3. Readable/understandable to anyone with a bachelors - why is this interesting, what did u solve, soln?
2. Background/Related Work (convince the reader, broad terms, contributions)
    1. Specification Languages/Specification vs Execution?
        1. Event-B
    2. Set-based languages
    3. Abstract Data Types
    4. High Level Program Optimization (and Term Rewriting)
    5. What other solns exist with a timeline, contributions expanded, define standards from other literature
3. Motivation
    1. Examples
        1. Information Systems
        2. Simulations
        3. Algorithmically-intense
4. The Simile Language (design, etc.)
5. High Level Optimization in Simile - TRS Specification
6. Implementation
    1. Jupyter
7. Conclusion
    1. Put contribution into perspective with tech details (assume paper was read)

## Requested Changes

- what to use for hilberts choice - make it a function `choice(S)` or `S.choice()`?
    - dont need, just use :: (:in) and force assignment, otherwise function would be fine
- make min and max general quantifiers: (min x . x in S | S) - use packrat parsing (just backtrack) to make min appear as a token instead of an identifier (to prevent confusion with the min function)
- support lattice notation for sets, seq, int, bool, etc types (ex. sqr versions of union, intersection, subset)? top and bottom?
- ⟨ and ⟩ for sequences (Z, CLRS, Back&Wright)
    - use << and >> for ascii equivalents?
    - and keep [ and ] for now
- bag: remove LADM notation, use 〚〛or ⟦⟧ or [[ and ]],
-/ ^ (Z, VDM) or + or ◦ (white circle) for sequence concatenation (Back&Wright use &)
    - using +
- /⇒ / => for implication, ⇐ / < = for consequence (short arrows)
    - drop consequence - just use reverse args of implication
    -  => for implication
/- ≡ / == for equivalence (not ⇔, as ≡ has the same meaning as = in typed logic, only binds weaker, but ⇔ has a different meaning)
-/ × / * for multiplication
    - Q: what about cartesian product? Event-B >< notation? right now, left in both
- div and mod for integer division and remainder (/ is reserved for rational / real / float, % is the wrong symbol); ÷ can be synonymous to div
    - `div` is only for integers, keep division symbol for reals
- leave out power for the time being (too complicated, likely not needed); adding exponentiation by a constant, written with superscripts, e.g. x³, is fine.
    - Q: I think leaving some ascii version of exponentiation would be desirable, either one of **/^ (ive seen both used in programming langs but okay with either). The exponentiation here will throw a type error if used on anything that's not a number, so things shouldnt be too complicated? Any concerns here? Using superscripts would make parsing more complicated... but definitely doable
    - take out double star, leave karat
- union_all → Union, intersection_all → Intersection
    - Q: maybe no capitalization? I agree with getting rid of _all
- x ↦ y is shorthand for (x, y)
    - Q: need to check with implementation on this. Should maplets be rewritten by the parser as tuples? tuple binds as tight as set notation/etc. The reason I moved maplets lower on the prcedence list is because of the mathlanguage cfg from before
    - leave precedence, add rewrite to tuple
-/ ⊕ for relational overwrite (even ChatGPT suggests that:-), to avoid non-Unicode
    - maybe make <+> alt instead of <+
- For Total / Surjective / Total Surjective Relation, we should avoid non-Unicode symbols; try to use some combining Unicode characters or character overlays; otherwise, the least ugly solution will do it for the time being.
- := (Unicode) / := (plain text) for assignment, avoiding arrows (arrows sometimes used in algorithms, but arrows will be used elsewhere, creates unnecessary ambiguity)
-/ "true", "false" lowercase, no "None"
-/ no "elif" (not an English word), but allow "else if"
- no "struct" (misnomer originating in C; everything composed is a structure); when needed, either "T = (f: F; g: G)" or "T = record f: F; g: G end" for declaring a record; would postpone that.
- no "enum", instead "T = (Monday, Tuesday)" (Pascal, order is implied, Monday < Tuesday, used in for-loop) or "T = {Monday, Tuesday}" (B, no order implied) without keyword
    - Q: I was planning on using enum only as a type. Eg. T : enum = {"Monday", "Tuesday"}, no order implied
-/ no "def" (Python misnomer, as "functions" used to be the only thing that could be defined in Python), either "procedure" (most precise), "method" (more common), or no keyword at all for procedure definition
- no "continue" (unless there is a strong reason in intermediate forms), leave out "break" for the time being, "return" is ok
-/ "pass" (Python-specific) → "skip" (common)
-/ Syntax: I would avoid angular brackets around nonterminals; they are not needed as terminals are in quotes
    - was using that bc of the grammar library guide, will change
- I would leave out the Comment nonterminal; if needed, easier to deal with in the scanner and more flexible, as comments can then appear anywhere
    - drop at scanner
- I am unsure if we need lambda expressions; we may not allow them to be assigned to variables; they would have to be part of map, filter, etc. operations. In general, they are needed, but I would put them on the back burner
    - assigning lambdas would be very useful for providing closures (eg. in game of life, to simplify the predicate, we could define a lambda function as a drop-in-replacement expression)
-/ I am unsure about PairExpr; it should be sufficient to have tuples, not just pairs. The typing rules should clarify that; I'll get back to that.
    - Q: move down to highest precidence?
- All relation and function symbols are part of expressions here. That works in B, as it is based on set theory, but does not work typed logic. In B you can write x := A → B, which assigns to x the set of all functions from A to B. In typed logic, A → B is a type, which is different from the set of all functions of that type; types cannot be assigned to variables. The type system will sort this out.
    - Q: should we allow users to write A->B to generate the largest set satisfying the relational constraints? leave out for now
- There are no local variables of the form "var x: 3 .. 5 · x := 4". While for-loops implicitly introduce a local variable, there may be other rewrite rules that explicitly introduce local variables.
    - explicit var keyword unneeded? see if its ambiguous eg. global, func with same name
    - using let x ... may just be easier...
- There are no type declarations of the form "type T = A → B x C". In B, these are called sets; here, we would call them types.
    - types are different from expressions in HoL (in python types are expressions and dont really matter to the compiler)
- http://lucacardelli.name/papers/typesystems.pdf there are several papers by Cardelli on type systems. That work aims at type checking, but does not get into the meaning of terms. It is a common way of defining types and is worth reading; can you go over it and we compare it with how B presents the typing rules?
- BackVonWright98RefinementCalculus uses HOL for verification. Several sections introduce HOL, though not quite from the basics. In HOL, types are implicit and therefore mostly not given (like in functional languages). It is still worth reading those sections
- This is another exposition of HOL, but I didn't see that it starts from the basics, it jumps quickly into using Isabelle. It is an easy introduction. https://isabelle.in.tum.de/doc/tutorial.pdf
- The HOL Light system is similar to Isabelle/HOL, but as the name suggests more primitive: https://hol-light.github.io/tutorial.pdf
- The original HOL theorem prover book and John Harrison's book present HOL properly; I didn't find comparable resources online, I'll give you my copies the next time.