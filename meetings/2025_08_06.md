# Agenda

- see open issues below

# TODOs
- Implement new trs that can handle all set notation
  - Figure out how to handle relations, relational subtypes, how to take advantage of that
- Investigate egraphs for term rewriting - see starred repo from other toy compiler
- MLIR for term rewriting output/codegen
- Data types for sets, relations - suggestions from the one chap from linkedin
- Find a benchmark to compare against!

# Compiler Progress

- Open issues:
  - two counter-examples on Teams
    - I need to delay equals substitution until after if-statements
    - Leave duplicate generators ungrouped and unoptimized for now
- Tasks:
  - composition - explicitly write exists - can get around this with imaging?
  - Powerpoint slides
    - big-o running time
    - teams message
  - TODO accumulator function for sets - maybe make a new AST node? Can just use rust inserts
- Postponed issues:
  - Singleton membership code generation - need special rewrite rule for free x in $x = e$ - could just exclude the rule for now and construct the full for loop
  - LLVM/MLIR target
  - translating bags to relations - how to count them up without pre-evaluating them? Are compile time rewrites sufficient?
  - dealing with subsets and powersets
    - look at prev. student examples
    - leave out powerset, subset generators for SYNT
    - can try postponing powerset to latest possible moment
      - or what if powerset arg is another more complex expression
    - check what alloy allows
  - leave out bags

## Legend

x - complete
\> - WIP/incomplete
< - complete, but no tests

## Status

- [x] Frontend
  - [x] Scanner
  - [x] AST
  - [x] Parser
  - [x] Bound/Free variable checks
  - [x] Scoping
  - [x] Type check pass
- [ ] Middle-end
  - [x] TRS design
  - [x] TRS infrastructure
  - [>] Add rules
  - [x] Break up rules/strategies into phases
  - [>] Test TRS
- [ ] Backend
  - [>] LLVM IR target - deferred, rust instead
  - [>] Pipeline trial (from plaintext to executable)
- [ ] Jupyter
  - [ ] Jupyter server for executing language - storing variables, using across multiple cells, etc
- Compiler addons progress
  - [ ] Better syntax error messages
  - [ ] Reverse compiler - AST-to-plaintext (formatter?)
  - [ ] Syntax highlighting
    - [ ] Design
    - [ ] VSCode
    - [ ] Jupyter
  - [ ] Target multiple architectures
- Other
  - [ ] Benchmarks against other languages
    - [ ] Implement examples in Python
    - [ ] Implement examples in Haskell
    - [ ] Implement examples in Rust
    - [ ] Implement examples in C
  - [ ] Test against AI-generated code
    - [ ] Need a fair prompt for each example

# Notes

- complexity measurements - big o notation - size of input vs size of output
- runtime guarantees, intermediate memory
- do all the relation rules (except composition might be tricky)

# Things to add to spec
The usual definitions are
x ∈ ∪ S  ≡ ∃ s ∈ S . x ∈ s  ≡  ∃ s . s ∈ S ∧ x ∈ s
x ∈ ∩ S  ≡  ∀ s ∈ S . x ∈ s. ≡  ∀ s . s ∈ S ⇒ x ∈ s
x ∈ {y . P | E}  ≡   ∃ y . P ∧ x = E
therefore
x ∈ ∪ s . P | E  ≡  ∃ s . P ∧ x ∈ E    the ∃ has to be made explicit
x ∈ ∩ s . P | E  ≡  ∀ s . P ⇒ x ∈ E     the ∀ has to be made explicit



# Optimizer Checklist
<!-- Syntactic Sugar for Bags -->
- [>] Bag Image
<!-- Builtin Functions -->
- [>] Cardinality
- [>] Domain
- [>] Range
<!-- Set Comprehension Construction -->
- [ ] Predicate Operations
- [ ] Singleton Membership
- [ ] Membership Collapse
<!-- DNF -->
- [ ] Flatten Nested AND
- [ ] Flatten Nested OR
- [ ] Double Negation
- [ ] Distribute De Morgan
- [ ] Distribute AND over OR
<!-- Predicate Simplification 1 -->
- [ ] Nesting
- [ ] OR-wrapping
<!-- Generator Selection -->
- [ ] Generator Selection
<!-- Predicate Simplification 2 -->
- [ ] Reduce Duplicate Generators
<!-- Predicate Simplification 3 -->
- [ ] Partially Normalized Disjunctive Form
<!-- Code Generation 1 -->
- [ ] Quantifier Generation
- [ ] Nested Quantifier
- [ ] Disjunct Conditional
<!-- Code Generation 2 -->
- [ ] Conjunct Conditional
<!-- Equality Elimination -->
- [ ] Equality Elimination
<!-- Relation -->
- [ ] Image
- [ ] Product
- [ ] Inverse
- [ ] Composition
- [ ] Exists Elimination
- [ ] Override
- [ ] Domain Restriction
- [ ] Domain Subtraction
- [ ] Range Restriction
- [ ] Range Subtraction

