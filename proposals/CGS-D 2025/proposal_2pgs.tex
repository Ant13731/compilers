\documentclass[12pt]{article}

\usepackage{latexsym}
\usepackage[empty]{fullpage}
\usepackage{titlesec}
\usepackage{marvosym}
\usepackage[usenames,dvipsnames]{color}
\usepackage{enumitem}
\usepackage{fancyhdr}
\usepackage[english]{babel}
\usepackage[dvipsnames]{xcolor}
\usepackage[backend=biber, maxbibnames=9]{biblatex}
\usepackage{fontawesome5}
\usepackage[hidelinks]{hyperref}

% \graphicspath{{./images/}}

% NOTE: need to run `biber *.tex` to ensure up-to-date references
\addbibresource{../reference.bib}
\addbibresource{resume.bib}
\DeclareBibliographyCategory{fullcited}

% \newcommand{\makeauthorbold}[1]{%
%   \DeclareNameFormat{author}{%
%     \ifthenelse{\value{listcount}=1}
%     {%
%       {\expandafter\ifstrequal\expandafter{\namepartfamily}{#1}{\mkbibbold{\namepartfamily\addcomma\addspace \namepartgiven}}{\namepartfamily\addcomma\addspace \namepartgiven}}
%       %
%     }{\ifnumless{\value{listcount}}{\value{liststop}}
%         {\expandafter\ifstrequal\expandafter{\namepartfamily}{#1}{\mkbibbold{\addcomma\addspace \namepartfamily\addcomma\addspace \namepartgiven}}{\addcomma\addspace \namepartfamily\addcomma\addspace \namepartgiven}}
%         {\expandafter\ifstrequal\expandafter{\namepartfamily}{#1}{\mkbibbold{\addcomma\addspace \namepartfamily\addcomma\addspace \namepartgiven\addcomma\isdot}}{\addcomma\addspace \namepartfamily\addcomma\addspace \namepartgiven\addcomma\isdot}}%
%       }
%     \ifthenelse{\value{listcount}<\value{liststop}}
%     {\addcomma\space}{}
%   }
% }
% \makeauthorbold{Hunt}

\title{CGS-D Scholarship Application}
\author{Anthony Hunt}

\begin{document}
\maketitle

\section{Thesis In-Progress Summary}

\subsection{Making an Efficient Very High-Level Programming Language: Optimization of Abstract Data Types}

\paragraph{Summary}
Sets, sequences, and relations are essential structures in formally defining system specifications. Executable modelling languages and high-level programming languages often expose these data types as syntactic sugar over more concrete notation.

Preliminary work on my current Master's thesis focused on prototyping a term rewriting system to generate efficient code from such abstract type operations. Thus far, we have conducted a literature review of abstract data types and term rewriting systems as components of optimizing compilers in the form of brief surveys. Then, to direct our exploration of the problem, we gathered around a dozen examples of formal system definitions and created a set of optimization rules to satisfy each example. Unifying these rules yielded generic optimization patterns especially when converting set operations like union or intersection to boolean-level quantification equivalents. We then implemented and presented a prototype compiler for set theory expressions at a program synthesis workshop (SYNT 2025), receiving excellent feedback incorporated in the complete project proposal.

% In the Thesis information page of your application, provide the full title and summary of your in-progress thesis. Include only work that has already been done; do not repeat the information provided in the Outline of proposed research section.

% For CGRS D, describe your bachelor’s (honours) or master’s thesis in this section. If you did not complete a previous thesis, you may describe one of your major research projects or papers or you may describe the work done to date on your doctoral degree.
\pagebreak
\section{Outline of Proposed Research}
% Two pages
% TODO CHECK FORMATTING!!!
% Provide a detailed yet concise description of your proposed research project for the period during which you are to hold the award. Be as specific as possible. Provide background information to position your proposed research within the context of the current knowledge in the field. State the significance of the proposed research to a field or fields in the NSE. State the objectives and hypothesis and outline the experimental or theoretical approach to be taken (citing literature pertinent to the proposal) and the methods and procedures to be used.

% In addition:

% Your research must be in the NSE.
% You should not repeat the information found in the Theses completed or in progress page, but you may refer to it.
% Include all relevant information in the outline. Do not refer review committee members to URLs or other publications for supplemental information. Such additional information will not be reviewed.
% If the proposed research is a continuation of your thesis, clearly state the differences between work done for your thesis and the research activities outlined in this proposal.
% Write your proposal in clear, plain language and avoid jargon. Your application will be evaluated by a review committee covering a broad discipline category.
% NSERC expects you to write your research proposal independently and to properly reference ideas or text belonging to others.
% NSERC encourages you to seek feedback from colleagues and supervisors.

%% Intro and hypothesis
Since the realization of the modern computer, programming languages have fundamentally shaped technological advancements and served as an interface for building unfathomably complex machines. However, among the thousands of available languages, relatively few manage to combine intuitive, high-level notation with reliably efficient execution. Our work seeks a resolution between the formal semantics and expressivity of specification languages (like UML, Event-B, and Dafny) and the performance of modern programming language implementations (as in Haskell and Rust) to answer the following:
\begin{enumerate}
  \item Can programming languages become more efficient and more expressive through the influence of specification languages?
  \item Which specification language expressions can be optimized for both runtime and memory consumption?
  \item How can we make a high-level programming language competitive with low-level language runtime performance?
\end{enumerate}

%% Why/Background
% Spec langs
System modelling and behaviour specifications commonly draw from set theory to define collections and relationships. Sets, sequences, and relations are pervasive in safety-critical software specifications, since their abstract nature, composed of theory-defined behaviours, lends well to proofs and guarantees of correctness. For example, Abrial's B method \cite{abrial2010modeling} was used in the 1990's to ensure safe design of the Paris Metro signaling system \cite{gerhart1994ParisMetro}. Further, Hoare logic, adopted by Dafny \cite{leino2023program}, is used to prove properties of imperative programs. Discrete mathematics and logic systems are essential to specification expressions that consider reliability a primary goal.

% Programming langs
Conversely, many popular programming languages stray from theory and generally force programmers to focus on the executable implementation. Arrays, heap-allocated memory, and classes are all implementation-aware constructs that, while closer to hardware, shifts the responsibility of overall system management onto the programmer. These types of programs, even from high-level languages, can be extremely difficult to prove following standard formal methods.

% Existing data types discussion (comparison with python)
While some high-level languages offer close alternatives to abstract collection types, as in Python, where lists parallel sequences and dictionaries parallel relations, they cannot support the full extent of theory-defined operators. Dictionaries alone are a many-to-one subset of abstract relations, since the underlying hashmap implementation prevents registration of duplicate keys with differing values. The Event-B specification language, on the other hand, provides convenient operators like relation composition or inverse, albeit with inefficient execution.

% Existing data types discussion - sets specifically (comparison with python)
Programming language sets mirror theoretical operations closely and provide efficient membership lookup through hashing, but successive operations are far more inefficient and memory-consuming than necessary. For example, in Python, finding the intersection of sets in an expression like $S \cap T \cap U$ would first generate an intermediate set for $S \cap T$ and then join the temporary set with $U$. While inefficient, this behaviour necessarily loops through $S \cap T$ twice because of implementation aware behaviour and expected side effects. A language closer to theory would instead calculate both intersections in one loop through $S$, checking against membership in both $T$ and $U$, without allocating more memory than absolutely required.

%% How/Approach
% Design
The new programming language we propose combines Event-B notation, Python-like code structure, and SetL's semi-automatic concrete data structure selection to enable concise expressions with mathematic semantics. Primitive operators like ($\land$) and ($\lor$) are expected to diverge from standard short circuiting to theory-correct commutative behaviour. Truly non-deterministic actions, like choosing a random element from a set, are natural to specifications but rarely found in conventional programming languages. We further plan to add type refinements according to set theory, enabling further static analysis and unlocking new optimizations.

% Compiler/TRS
Because abstract data types serve as the mathematical and programmatic foundation for our language, our term rewriting compiler transforms equational theorems into directed, provably semantic-preserving, high-level optimization passes. Rewrite rules based on abstract type and operation semantics can eliminate all excess intermediate memory allocation in complex expressions, improving upon default imperative language behaviour. Type extensions involving, for example, the injective, surjective, or totality properties of a relation can further reduce superfluous relationship lookups and implicitly direct the actualized structure of variables.

We anticipate a term rewriting system that can refine abstract structures into varying concrete implementations, depending on the situation. For example, generic sets are commonly represented by a hashset, but sets of dense or sparse integer collections may find better performance with a bitset or roaring bitsets respectively. Relations, which default to a single-direction hashmap, may find better performance in bi-directional hashmap for efficient inverse lookup and representation of many-to-many relations. Recent work in tree-based path-map structures \cite{jones2024triemapsmatch} may offer even more efficient operation execution by precluding the need for an iteration over an entire relation. Once high-level optimization passes are complete, we lower the now-concrete data structures into LLVM assembly, conveniently harnessing decades of low level optimization work \cite{lattner2002llvm}.

A successful language should be far more efficient than interpreted high-level languages like Python and JavaScript, with competitive runtime compared to idiomatically-written low-level C or Rust code. Memory usage should be optimal, undercutting any eagerly-evaluated programming language. Programming language benchmarks will be created based on three categories: algorithmically-intense computations, complex simulations, and data-heavy information systems.


%% Conclusion
% Why/Anticipated results/what the field gains from finding a positive/negative resolution to the topic
Providing an efficient high-level language brings software engineering closer to the specification design and simplifies verification of program correctness. Hoare logic program guarantees may now be written directly as part of the program and used in the optimization process, rather than relegating useful semantic information to only exist in documentation form. Additionally, direct usability benefits from borrowing purer mathematical notation may increase adoption of formal methods and accessibility of safety-critical programming to novice programmers, increasing the overall safety and efficiency of software systems.

\pagebreak
\section{Contributions and Statements}
% Two pages
\subsection{Contributions to research and development}
\addtocategory{fullcited}{hunt2021information}
\addtocategory{fullcited}{hunt2024memautogui}
\addtocategory{fullcited}{hunt2025generating}

\subsubsection*{I. c.}
\textbf{Anthony Hunt*} and Emil Sekerinski. (2025) Generating Implementations of Data Type Operations. Workshop on Synthesis (co-located with the International Conference on Computer Aided Verification). Pages: 3 (Master's work, workshop presentation).
\\\\
\textbf{Anthony Hunt*}, Jacques Carette, and Spencer Smith. (2021) Information Encoding and Traceability in Software. Annual Undergraduate Student Research Poster Showcase at McMaster University (Undergraduate work, poster).

\subsubsection*{I. d.}
\textbf{Anthony Hunt} and Hamid Hosseiny. (2024) MemAutoGUI: An Enhanced Automation Approach for Accelerated Validation Focused on Usability. In: \textit{Design and Test Technology Conference}. Pages: 10. Intel (Work done with team lead during an internship, international conference).


\subsection{Most significant contributions to research and development}
\subsection{Applicant's statement}

\pagebreak
\section{Equity, Diversity, and Inclusion Considerations}
Although the creation of a mathematics-focused programming language may not present the same equity, diversity, and inclusion concerns as a human-centered experiment, we nonetheless consider accessibility impact in our work. Similar to standard programming languages, the interface language is through text based files. However, we aim to support both unicode and ASCII characters for better symbolic representation of mathematics. This, in turn, may assist text-to-speech programs for the visually impaired by using more concise and relevant symbols. As a simple example, consider the ASCII notation for the expression of a relation \texttt{S <-> T}. Replacing the ``less than, dash, greater than'' character sequence with ($\leftrightarrow$) is more straightforward and understandable in a programming context.

% \section{Bibliography}
% Five pages maximum
\pagebreak
\nocite{*} % keeps all references, even those not referred to
\printbibliography[notcategory=fullcited] %Prints bibliography

\end{document}