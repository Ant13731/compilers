\documentclass{article}
\usepackage{biblatex}
% NOTE: need to run `biber adt_survey` to ensure up-to-date references
\addbibresource{adt_survey.bib}

\title{A Survey on Abstract Data Types}
\author{Anthony Hunt}

\begin{document}
\maketitle

\section{Introduction}

From the categorization of species to the periodic table of elements, the organization and manipulation
of data is integral to all aspects of science and technology. Although the collection of data is not a
new field of research by any means, the advent of computerized systems, with its ability to transfer and use
massive amounts of data in mere seconds, necessitates understandable and sensible organization structures.

Over the past 60 years, as computational resource restrictions have eased dramatically,
programming languages and software creation tools have evolved with increasingly better methods of dealing with data.
By viewing pieces of data through specific lenses, programmers can then write algorithms that operate on
any data matching the shape of those lenses, rather than the data itself. These lenses are more commonly referred to as
data types, which assign a type to a piece of data. As we will see later in this paper,
further abstractions over data types themselves enable extremely concise and readable code,
both for the programmer and computer.

The rest of this article will explore data type concepts from <X> languages, % TODO FILL IN
structures to handle errors that might appear, and a small review of ergonomics and usability of those data types.

\section{Data Types in <X>+ Languages} % TODO fill in value for X!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

Abstract Data Types (ADTs) can look quite different in many languages, but often share the same principles and rules
that make it understandable for programmers. In its essential form, an ADT is a collection of data together with
operations that can be carried out on that data \cite{ADTspec}. The key differences between ADTs from different languages
are the conventions used to collect data and the power operations have over collected data.

In popular object-oriented programming (OOP) languages,
ADTs are approached with a ``class'' mindset, where programmers specify a blueprint for objects that
will eventually be used in a program. For better code reuse, classes can be built from pre-existing classes
through the use of inheritance, a term used to express that a new class inherits all the properties of the old class.
Objects created by classes are referred to as instances of the class and often hold
some amount of mutable data, with methods that have full access to the data. The methods can choose to make use of
``side effects'', referring to the modification of data not explicitly passed through
regular function arguments or return values. Side effects in methods have the consequence that the output of
a method may change independent of the values passed through its arguments. In other words,
the object a method has access to may contain some state that influences the outcome of the method.

At the opposite end of the programming world lies purely functional languages. ADTs in these languages
are more often referred to as data types rather than classes and are only used for collecting and operating on data.
``Objects'' created from these data types are immutable and methods are instead replaced with pure functions that
explicitly take in the relevant data type as input. The operators attached to a functionally pure ADT are functionally pure themselves,
meaning they cannot make use of any hidden state and therefore cannot have side effects.

% Type to express in all languages - a simple linked list, with append and concatenate methods
\subsection{Python}

\subsection{TypeScript}
\subsection{C++}
\subsection{Rust}
\subsection{Dafny}
\subsection{Haskell}
\subsection{Agda}
\subsection{APL}
\subsection{UML}
\subsection{Event-B}
\subsection{SETL} %Maybe? Would need to cite
\subsection{Bend} %Maybe? Would need to cite
\subsection{Exploration of Conceptual Data Types}
\section{Error Handling and Undefinedness}
\section{A Word on Usability}
\section{Conclusion}


\nocite{*} % keeps all references, even those not referred to
\printbibliography %Prints bibliography

\end{document}